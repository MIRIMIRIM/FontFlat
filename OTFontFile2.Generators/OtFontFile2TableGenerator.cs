using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace OTFontFile2.Generators;

[Generator]
public sealed class OtFontFile2TableGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var tables = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (node, _) => node is StructDeclarationSyntax s && s.AttributeLists.Count > 0 && s.Modifiers.Any(SyntaxKind.PartialKeyword),
                transform: static (ctx, _) => GetTableInfo(ctx))
            .Where(static info => info is not null)
            .Select(static (info, _) => info!);

        context.RegisterSourceOutput(tables, static (spc, info) => Execute(spc, info!));

        context.RegisterSourceOutput(tables.Collect(), static (spc, infos) => ExecuteCollected(spc, infos));
    }

    private static void ExecuteCollected(SourceProductionContext context, ImmutableArray<TableInfo> infos)
    {
        context.AddSource(
            "OTFontFile2.SfntFontTableExtensions.g.cs",
            SourceText.From(GenerateSfntFontTableExtensions(infos), Encoding.UTF8));

        context.AddSource(
            "OTFontFile2.KnownTags.g.cs",
            SourceText.From(GenerateKnownTags(infos), Encoding.UTF8));
    }

    private static string GenerateSfntFontTableExtensions(ImmutableArray<TableInfo> infos)
    {
        var tables = infos
            .Where(static t => t.Kind == TableKind.Table && t.Type.Accessibility == Accessibility.Public && t.ContainingTypes.Length == 0)
            .OrderBy(static t => t.Type.Name, StringComparer.Ordinal)
            .ToArray();

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("namespace OTFontFile2.Tables;");
        sb.AppendLine();
        sb.AppendLine("public static partial class SfntFontTableExtensions");
        sb.AppendLine("{");

        foreach (var info in tables)
        {
            string typeName = info.Type.Name;
            string baseName = typeName.EndsWith("Table", StringComparison.Ordinal)
                ? typeName.Substring(0, typeName.Length - "Table".Length)
                : typeName;

            string methodName = "TryGet" + baseName;

            string outName;
            if (string.Equals(baseName, "Base", StringComparison.Ordinal))
                outName = "baseTable";
            else if (baseName.Length == 1)
                outName = baseName.ToLowerInvariant();
            else
                outName = char.ToLowerInvariant(baseName[0]) + baseName.Substring(1);

            uint tagValue = TagToUInt32(info.Tag);

            sb.AppendLine($"    public static bool {methodName}(this SfntFont font, out {typeName} {outName})");
            sb.AppendLine("    {");
            sb.AppendLine($"        {outName} = default;");
            sb.AppendLine($"        return font.TryGetTableSlice(new Tag(0x{tagValue:X8}u), out var slice) && {typeName}.TryCreate(slice, out {outName});");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenerateKnownTags(ImmutableArray<TableInfo> infos)
    {
        var tags = infos
            .Where(static t => t.Kind == TableKind.Table && t.Tag.Length == 4)
            .Select(static t => t.Tag)
            .Distinct(StringComparer.Ordinal)
            .ToArray();

        var entries = new List<TagEntry>(tags.Length);
        foreach (var tag in tags)
        {
            entries.Add(new TagEntry(
                Tag: tag,
                Name: GetKnownTagsFieldName(tag),
                Value: TagToUInt32(tag)));
        }

        entries.Sort(static (a, b) => StringComparer.Ordinal.Compare(a.Name, b.Name));

        var uniqueNames = new HashSet<string>(StringComparer.Ordinal);
        var normalized = new List<TagEntry>(entries.Count);
        foreach (var entry in entries)
        {
            string name = entry.Name;
            if (!uniqueNames.Add(name))
            {
                name = name + "_" + entry.Value.ToString("X8");
                int i = 2;
                while (!uniqueNames.Add(name))
                    name = entry.Name + "_" + entry.Value.ToString("X8") + "_" + i++;
            }

            normalized.Add(entry with { Name = name });
        }

        normalized.Sort(static (a, b) => StringComparer.Ordinal.Compare(a.Name, b.Name));

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("namespace OTFontFile2;");
        sb.AppendLine();
        sb.AppendLine("public static partial class KnownTags");
        sb.AppendLine("{");

        foreach (var entry in normalized)
        {
            sb.AppendLine($"    public static readonly Tag {entry.Name} = new(0x{entry.Value:X8}u); // '{entry.Tag}'");
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GetKnownTagsFieldName(string tag)
    {
        // Historical naming aliases within OTFontFile2.
        if (string.Equals(tag, "bdat", StringComparison.Ordinal))
            return "BDAT";
        if (string.Equals(tag, "bloc", StringComparison.Ordinal))
            return "BLOC";

        var sb = new StringBuilder(4);
        foreach (char c in tag)
        {
            if (char.IsLetterOrDigit(c))
                sb.Append(c);
        }

        string name = sb.ToString();
        if (name.Length == 0)
            name = "Tag_" + TagToUInt32(tag).ToString("X8");

        if (char.IsDigit(name[0]))
            name = "_" + name;

        return name;
    }

    private static TableInfo? GetTableInfo(GeneratorSyntaxContext context)
    {
        var structDecl = (StructDeclarationSyntax)context.Node;
        if (context.SemanticModel.GetDeclaredSymbol(structDecl) is not INamedTypeSymbol symbol)
            return null;

        string hintName = GetHintBaseName(symbol);

        AttributeData? tableAttr = null;
        AttributeData? subTableAttr = null;
        foreach (var a in symbol.GetAttributes())
        {
            if (a.AttributeClass?.Name == "OtTableAttribute"
                && a.AttributeClass.ContainingNamespace.ToDisplayString() == "OTFontFile2.SourceGen")
            {
                tableAttr = a;
                break;
            }
        }

        if (tableAttr is null)
        {
            foreach (var a in symbol.GetAttributes())
            {
                if (a.AttributeClass?.Name == "OtSubTableAttribute"
                    && a.AttributeClass.ContainingNamespace.ToDisplayString() == "OTFontFile2.SourceGen")
                {
                    subTableAttr = a;
                    break;
                }
            }
        }

        TableKind kind;
        string tag;
        int minLength;
        bool generateTryCreate;
        bool generateStorage;
        bool generateBuilder;
        string? builderName;

        if (tableAttr is not null)
        {
            kind = TableKind.Table;
            tag = tableAttr.ConstructorArguments.Length >= 1 ? (tableAttr.ConstructorArguments[0].Value?.ToString() ?? string.Empty) : string.Empty;
            minLength = tableAttr.ConstructorArguments.Length >= 2 && tableAttr.ConstructorArguments[1].Value is int ml ? ml : 0;

            generateBuilder = false;
            generateTryCreate = true;
            generateStorage = true;
            builderName = null;
            foreach (var kv in tableAttr.NamedArguments)
            {
                if (kv.Key == "GenerateBuilder" && kv.Value.Value is bool gb)
                    generateBuilder = gb;
                else if (kv.Key == "GenerateTryCreate" && kv.Value.Value is bool gtc)
                    generateTryCreate = gtc;
                else if (kv.Key == "GenerateStorage" && kv.Value.Value is bool gs)
                    generateStorage = gs;
                else if (kv.Key == "BuilderName" && kv.Value.Value is string bn)
                    builderName = bn;
            }
        }
        else if (subTableAttr is not null)
        {
            kind = TableKind.SubTable;
            tag = string.Empty;
            minLength = subTableAttr.ConstructorArguments.Length >= 1 && subTableAttr.ConstructorArguments[0].Value is int ml ? ml : 0;

            generateTryCreate = true;
            generateStorage = true;
            foreach (var kv in subTableAttr.NamedArguments)
            {
                if (kv.Key == "GenerateTryCreate" && kv.Value.Value is bool gtc)
                    generateTryCreate = gtc;
                else if (kv.Key == "GenerateStorage" && kv.Value.Value is bool gs)
                    generateStorage = gs;
            }

            generateBuilder = false;
            builderName = null;
        }
        else
        {
            return null;
        }

        var containingTypes = GetContainingTypes(symbol);
        var typeInfo = new TypeInfo(
            Name: symbol.Name,
            TypeKind: symbol.TypeKind,
            Accessibility: symbol.DeclaredAccessibility,
            IsReadOnly: symbol.IsReadOnly,
            IsRefLike: symbol.IsRefLikeType,
            IsStatic: symbol.IsStatic,
            IsRecord: symbol.IsRecord,
            IsPartial: IsPartial(symbol),
            Arity: symbol.TypeParameters.Length);

        var fields = new List<FieldInfo>();
        string? discriminantFieldName = null;
        string? discriminatedUnionError = null;
        var discriminatedCases = new List<DiscriminatedCaseInfo>();
        var recordArrays = new List<TagOffsetRecordArrayInfo>();
        var u16Arrays = new List<UInt16ArrayInfo>();
        var u32Arrays = new List<UInt32ArrayInfo>();
        var sequentialRecordArrays = new List<SequentialRecordArrayInfo>();
        var subTableOffsets = new List<SubTableOffsetInfo>();
        var subTableOffsetArrays = new List<SubTableOffsetArrayInfo>();
        foreach (var a in symbol.GetAttributes())
        {
            if (a.AttributeClass?.Name == "OtDiscriminantAttribute" &&
                a.AttributeClass.ContainingNamespace.ToDisplayString() == "OTFontFile2.SourceGen")
            {
                if (a.ConstructorArguments.Length < 1)
                {
                    discriminatedUnionError ??= "OtDiscriminant requires a fieldName.";
                    continue;
                }

                string discriminantName = a.ConstructorArguments[0].Value?.ToString() ?? string.Empty;
                if (string.IsNullOrWhiteSpace(discriminantName))
                {
                    discriminatedUnionError ??= "FieldName cannot be empty.";
                    continue;
                }

                if (discriminantFieldName is not null && !string.Equals(discriminantFieldName, discriminantName, StringComparison.Ordinal))
                    discriminatedUnionError ??= "Multiple OtDiscriminant attributes are not supported.";

                discriminantFieldName = discriminantName;
                continue;
            }

            if (a.AttributeClass?.Name == "OtCaseAttribute" &&
                a.AttributeClass.ContainingNamespace.ToDisplayString() == "OTFontFile2.SourceGen")
            {
                int value = 0;
                string name = string.Empty;
                string? outParameterName = null;
                string variantTypeName = string.Empty;
                CaseVariantKind variantKind = CaseVariantKind.Unknown;
                string? error = null;

                if (a.ConstructorArguments.Length < 2)
                {
                    error = "OtCase requires (value, variantType).";
                }
                else
                {
                    value = a.ConstructorArguments[0].Value is int v ? v : 0;

                    if (a.ConstructorArguments[1].Value is ITypeSymbol ts)
                    {
                        variantTypeName = ts.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                        name = ts.Name;

                        if (ts is INamedTypeSymbol namedTs)
                        {
                            foreach (var ta in namedTs.GetAttributes())
                            {
                                if (ta.AttributeClass?.Name == "OtSubTableAttribute" &&
                                    ta.AttributeClass.ContainingNamespace.ToDisplayString() == "OTFontFile2.SourceGen")
                                {
                                    variantKind = CaseVariantKind.SubTable;
                                    break;
                                }

                                if (ta.AttributeClass?.Name == "OtTableAttribute" &&
                                    ta.AttributeClass.ContainingNamespace.ToDisplayString() == "OTFontFile2.SourceGen")
                                {
                                    variantKind = CaseVariantKind.Table;
                                    break;
                                }
                            }
                        }
                    }
                    else
                    {
                        error = "VariantType must be a concrete type.";
                    }

                    foreach (var kv in a.NamedArguments)
                    {
                        if (kv.Key == "Name" && kv.Value.Value is string n)
                            name = n;
                        else if (kv.Key == "OutParameterName" && kv.Value.Value is string opn)
                            outParameterName = opn;
                    }

                    if (string.IsNullOrWhiteSpace(name))
                        error ??= "Name cannot be empty.";
                    if (outParameterName is not null && string.IsNullOrWhiteSpace(outParameterName))
                        error ??= "OutParameterName cannot be empty when specified.";
                    if (string.IsNullOrWhiteSpace(variantTypeName))
                        error ??= "VariantType must be a concrete type.";
                    if (variantKind == CaseVariantKind.Unknown)
                        error ??= "VariantType must be marked with [OtTable] or [OtSubTable].";
                }

                discriminatedCases.Add(new DiscriminatedCaseInfo(value, variantTypeName, variantKind, name, outParameterName, error));
                continue;
            }

            if (a.AttributeClass?.Name == "OtTagOffsetRecordArrayAttribute" &&
                a.AttributeClass.ContainingNamespace.ToDisplayString() == "OTFontFile2.SourceGen")
            {
                if (a.ConstructorArguments.Length < 2)
                    continue;

                string arrayName = a.ConstructorArguments[0].Value?.ToString() ?? string.Empty;
                int recordsOffset = a.ConstructorArguments[1].Value is int ro ? ro : 0;

                string? countPropertyName = null;
                bool offset32 = false;
                string? subTableTypeName = null;
                string? outParameterName = null;
                foreach (var kv in a.NamedArguments)
                {
                    if (kv.Key == "CountPropertyName" && kv.Value.Value is string cpn)
                        countPropertyName = cpn;
                    else if (kv.Key == "Offset32" && kv.Value.Value is bool o32)
                        offset32 = o32;
                    else if (kv.Key == "SubTableType" && kv.Value.Value is ITypeSymbol ts)
                        subTableTypeName = ts.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
                    else if (kv.Key == "OutParameterName" && kv.Value.Value is string opn)
                        outParameterName = opn;
                }

                recordArrays.Add(new TagOffsetRecordArrayInfo(arrayName, recordsOffset, countPropertyName, offset32, subTableTypeName, outParameterName, ErrorMessage: null));
                continue;
            }

            if (a.AttributeClass?.Name == "OtUInt16ArrayAttribute" &&
                a.AttributeClass.ContainingNamespace.ToDisplayString() == "OTFontFile2.SourceGen")
            {
                if (a.ConstructorArguments.Length < 2)
                    continue;

                string arrayName = a.ConstructorArguments[0].Value?.ToString() ?? string.Empty;
                int valuesOffset = a.ConstructorArguments[1].Value is int vo ? vo : 0;

                string? valuesOffsetExpression = null;
                string? boundsLengthExpression = null;
                string? countPropertyName = null;
                string? outParameterName = null;
                int countAdjustment = 0;
                foreach (var kv in a.NamedArguments)
                {
                    if (kv.Key == "ValuesOffsetExpression" && kv.Value.Value is string voe)
                        valuesOffsetExpression = voe;
                    else if (kv.Key == "BoundsLengthExpression" && kv.Value.Value is string ble)
                        boundsLengthExpression = ble;
                    else if (kv.Key == "CountPropertyName" && kv.Value.Value is string cpn)
                        countPropertyName = cpn;
                    else if (kv.Key == "OutParameterName" && kv.Value.Value is string opn)
                        outParameterName = opn;
                    else if (kv.Key == "CountAdjustment" && kv.Value.Value is int ca)
                        countAdjustment = ca;
                }

                u16Arrays.Add(new UInt16ArrayInfo(arrayName, valuesOffset, valuesOffsetExpression, boundsLengthExpression, countPropertyName, outParameterName, countAdjustment));
                continue;
            }

            if (a.AttributeClass?.Name == "OtUInt32ArrayAttribute" &&
                a.AttributeClass.ContainingNamespace.ToDisplayString() == "OTFontFile2.SourceGen")
            {
                if (a.ConstructorArguments.Length < 2)
                    continue;

                string arrayName = a.ConstructorArguments[0].Value?.ToString() ?? string.Empty;
                int valuesOffset = a.ConstructorArguments[1].Value is int vo ? vo : 0;

                string? valuesOffsetExpression = null;
                string? boundsLengthExpression = null;
                string? countPropertyName = null;
                string? outParameterName = null;
                int countAdjustment = 0;
                foreach (var kv in a.NamedArguments)
                {
                    if (kv.Key == "ValuesOffsetExpression" && kv.Value.Value is string voe)
                        valuesOffsetExpression = voe;
                    else if (kv.Key == "BoundsLengthExpression" && kv.Value.Value is string ble)
                        boundsLengthExpression = ble;
                    else if (kv.Key == "CountPropertyName" && kv.Value.Value is string cpn)
                        countPropertyName = cpn;
                    else if (kv.Key == "OutParameterName" && kv.Value.Value is string opn)
                        outParameterName = opn;
                    else if (kv.Key == "CountAdjustment" && kv.Value.Value is int ca)
                        countAdjustment = ca;
                }

                u32Arrays.Add(new UInt32ArrayInfo(arrayName, valuesOffset, valuesOffsetExpression, boundsLengthExpression, countPropertyName, outParameterName, countAdjustment));
                continue;
            }

            if (a.AttributeClass?.Name == "OtSequentialRecordArrayAttribute" &&
                a.AttributeClass.ContainingNamespace.ToDisplayString() == "OTFontFile2.SourceGen")
            {
                if (a.ConstructorArguments.Length < 3)
                    continue;

                string arrayName = a.ConstructorArguments[0].Value?.ToString() ?? string.Empty;
                int recordsOffset = a.ConstructorArguments[1].Value is int ro ? ro : 0;
                int recordSize = a.ConstructorArguments[2].Value is int rs ? rs : 0;

                string? recordsOffsetExpression = null;
                string? boundsLengthExpression = null;
                string? recordStrideExpression = null;
                string? countPropertyName = null;
                string? recordTypeName = null;
                string? outParameterName = null;
                foreach (var kv in a.NamedArguments)
                {
                    if (kv.Key == "RecordsOffsetExpression" && kv.Value.Value is string roe)
                        recordsOffsetExpression = roe;
                    else if (kv.Key == "BoundsLengthExpression" && kv.Value.Value is string ble)
                        boundsLengthExpression = ble;
                    else if (kv.Key == "RecordStrideExpression" && kv.Value.Value is string rse)
                        recordStrideExpression = rse;
                    else if (kv.Key == "CountPropertyName" && kv.Value.Value is string cpn)
                        countPropertyName = cpn;
                    else if (kv.Key == "RecordTypeName" && kv.Value.Value is string rtn)
                        recordTypeName = rtn;
                    else if (kv.Key == "OutParameterName" && kv.Value.Value is string opn)
                        outParameterName = opn;
                }

                string resolvedRecordTypeName = recordTypeName ?? arrayName;
                sequentialRecordArrays.Add(CreateSequentialRecordArrayInfo(context.SemanticModel.Compilation, symbol, arrayName, recordsOffset, recordsOffsetExpression, boundsLengthExpression, recordStrideExpression, recordSize, countPropertyName, resolvedRecordTypeName, outParameterName));
                continue;
            }

            if (a.AttributeClass?.Name == "OtSubTableOffsetAttribute" &&
                a.AttributeClass.ContainingNamespace.ToDisplayString() == "OTFontFile2.SourceGen")
            {
                if (a.ConstructorArguments.Length < 3)
                    continue;

                string accessorName = a.ConstructorArguments[0].Value?.ToString() ?? string.Empty;
                string offsetPropertyName = a.ConstructorArguments[1].Value?.ToString() ?? string.Empty;

                string subTableTypeName = string.Empty;
                if (a.ConstructorArguments[2].Value is ITypeSymbol ts)
                    subTableTypeName = ts.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                string? outParameterName = null;
                bool relativeToTableStart = false;
                foreach (var kv in a.NamedArguments)
                {
                    if (kv.Key == "RelativeToTableStart" && kv.Value.Value is bool rtts)
                        relativeToTableStart = rtts;
                    else if (kv.Key == "OutParameterName" && kv.Value.Value is string opn)
                        outParameterName = opn;
                }

                subTableOffsets.Add(new SubTableOffsetInfo(accessorName, offsetPropertyName, subTableTypeName, outParameterName, relativeToTableStart, ErrorMessage: null));
                continue;
            }

            if (a.AttributeClass?.Name == "OtSubTableOffsetArrayAttribute" &&
                a.AttributeClass.ContainingNamespace.ToDisplayString() == "OTFontFile2.SourceGen")
            {
                if (a.ConstructorArguments.Length < 3)
                    continue;

                string accessorName = a.ConstructorArguments[0].Value?.ToString() ?? string.Empty;
                string offsetArrayName = a.ConstructorArguments[1].Value?.ToString() ?? string.Empty;

                string subTableTypeName = string.Empty;
                if (a.ConstructorArguments[2].Value is ITypeSymbol ts)
                    subTableTypeName = ts.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

                string? outParameterName = null;
                bool relativeToTableStart = false;
                foreach (var kv in a.NamedArguments)
                {
                    if (kv.Key == "RelativeToTableStart" && kv.Value.Value is bool rtts)
                        relativeToTableStart = rtts;
                    else if (kv.Key == "OutParameterName" && kv.Value.Value is string opn)
                        outParameterName = opn;
                }

                subTableOffsetArrays.Add(new SubTableOffsetArrayInfo(accessorName, offsetArrayName, subTableTypeName, outParameterName, relativeToTableStart, ErrorMessage: null));
                continue;
            }

            if (a.AttributeClass?.Name != "OtFieldAttribute" ||
                a.AttributeClass.ContainingNamespace.ToDisplayString() != "OTFontFile2.SourceGen")
                continue;

            if (a.ConstructorArguments.Length < 3)
                continue;

            string fieldName = a.ConstructorArguments[0].Value?.ToString() ?? string.Empty;
            int fieldKind = a.ConstructorArguments[1].Value is int k ? k : 0;
            int offset = a.ConstructorArguments[2].Value is int o ? o : 0;

            int length = 0;
            bool inView = true;
            bool inBuilder = true;
            bool hasDefaultValue = false;
            long defaultValue = 0;
            byte padByte = 0;

            foreach (var kv in a.NamedArguments)
            {
                switch (kv.Key)
                {
                    case "Length" when kv.Value.Value is int l:
                        length = l;
                        break;
                    case "InView" when kv.Value.Value is bool iv:
                        inView = iv;
                        break;
                    case "InBuilder" when kv.Value.Value is bool ib:
                        inBuilder = ib;
                        break;
                    case "HasDefaultValue" when kv.Value.Value is bool hd:
                        hasDefaultValue = hd;
                        break;
                    case "DefaultValue" when kv.Value.Value is long dv:
                        defaultValue = dv;
                        break;
                    case "PadByte" when kv.Value.Value is byte pb:
                        padByte = pb;
                        break;
                }
            }

            fields.Add(new FieldInfo(fieldName, (OtFieldKind)fieldKind, offset, length, inView, inBuilder, hasDefaultValue, defaultValue, padByte));
        }

        for (int i = 0; i < recordArrays.Count; i++)
        {
            var a = recordArrays[i];
            string? error = null;

            if (a.SubTableTypeName is not null)
            {
                if (string.IsNullOrWhiteSpace(a.SubTableTypeName))
                    error = "SubTableType must be a concrete type when specified.";
                else if (a.OutParameterName is not null && string.IsNullOrWhiteSpace(a.OutParameterName))
                    error = "OutParameterName cannot be empty when specified.";
            }

            if (error is not null)
                recordArrays[i] = a with { ErrorMessage = error };
        }

        for (int i = 0; i < subTableOffsets.Count; i++)
        {
            var o = subTableOffsets[i];
            string? error = null;

            if (string.IsNullOrWhiteSpace(o.Name))
                error = "Name cannot be empty.";
            else if (string.IsNullOrWhiteSpace(o.OffsetPropertyName))
                error = "OffsetPropertyName cannot be empty.";
            else if (string.IsNullOrWhiteSpace(o.SubTableTypeName))
                error = "SubTableType must be a concrete type.";
            else if (o.OutParameterName is not null && string.IsNullOrWhiteSpace(o.OutParameterName))
                error = "OutParameterName cannot be empty when specified.";
            else
            {
                FieldInfo? offsetField = null;
                for (int f = 0; f < fields.Count; f++)
                {
                    var field = fields[f];
                    if (field.InView && field.Name == o.OffsetPropertyName)
                    {
                        offsetField = field;
                        break;
                    }
                }

                if (offsetField is null)
                {
                    error = $"Offset property '{o.OffsetPropertyName}' was not found as an [OtField] with InView=true.";
                }
                else if (offsetField.Kind is not (OtFieldKind.UInt16 or OtFieldKind.UInt24 or OtFieldKind.UInt32))
                {
                    error = $"Offset property '{o.OffsetPropertyName}' must be OtFieldKind.UInt16, OtFieldKind.UInt24, or OtFieldKind.UInt32 (was {offsetField.Kind}).";
                }
            }

            if (error is not null)
                subTableOffsets[i] = o with { ErrorMessage = error };
        }

        for (int i = 0; i < subTableOffsetArrays.Count; i++)
        {
            var o = subTableOffsetArrays[i];
            string? error = null;

            if (string.IsNullOrWhiteSpace(o.Name))
                error = "Name cannot be empty.";
            else if (string.IsNullOrWhiteSpace(o.OffsetArrayName))
                error = "OffsetArrayName cannot be empty.";
            else if (string.IsNullOrWhiteSpace(o.SubTableTypeName))
                error = "SubTableType must be a concrete type.";
            else if (o.OutParameterName is not null && string.IsNullOrWhiteSpace(o.OutParameterName))
                error = "OutParameterName cannot be empty when specified.";
            else
            {
                bool found = false;
                for (int a = 0; a < u16Arrays.Count; a++)
                {
                    if (u16Arrays[a].Name == o.OffsetArrayName)
                    {
                        found = true;
                        break;
                    }
                }

                if (!found)
                {
                    for (int a = 0; a < u32Arrays.Count; a++)
                    {
                        if (u32Arrays[a].Name == o.OffsetArrayName)
                        {
                            found = true;
                            break;
                        }
                    }
                }

                if (!found)
                    error = $"Offset array '{o.OffsetArrayName}' was not found as an [OtUInt16Array] or [OtUInt32Array].";
            }

            if (error is not null)
                subTableOffsetArrays[i] = o with { ErrorMessage = error };
        }

        DiscriminatedUnionInfo? discriminatedUnion = null;
        if (discriminantFieldName is not null || discriminatedCases.Count != 0 || discriminatedUnionError is not null)
        {
            string? error = discriminatedUnionError;
            if (discriminantFieldName is null)
                error ??= "OtCase specified without OtDiscriminant.";
            else if (discriminatedCases.Count == 0)
                error ??= "OtDiscriminant specified without any OtCase.";

            discriminatedUnion = new DiscriminatedUnionInfo(
                DiscriminantFieldName: discriminantFieldName,
                Cases: discriminatedCases.ToImmutableArray(),
                ErrorMessage: error);
        }

        return new TableInfo(
            Kind: kind,
            HintName: hintName,
            Namespace: symbol.ContainingNamespace.ToDisplayString(),
            Type: typeInfo,
            ContainingTypes: containingTypes,
            Tag: tag,
            MinLength: minLength,
            GenerateTryCreate: generateTryCreate,
            GenerateStorage: generateStorage,
            GenerateBuilder: generateBuilder,
            BuilderName: builderName,
            DiscriminatedUnion: discriminatedUnion,
            Fields: fields.ToImmutableArray(),
            TagOffsetRecordArrays: recordArrays.ToImmutableArray(),
            UInt16Arrays: u16Arrays.ToImmutableArray(),
            UInt32Arrays: u32Arrays.ToImmutableArray(),
            SequentialRecordArrays: sequentialRecordArrays.ToImmutableArray(),
            SubTableOffsets: subTableOffsets.ToImmutableArray(),
            SubTableOffsetArrays: subTableOffsetArrays.ToImmutableArray());
    }

    private static void Execute(SourceProductionContext context, TableInfo info)
    {
        if (info.Type.Arity != 0 || info.ContainingTypes.Any(static t => t.Arity != 0))
        {
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    id: "OTFF2SG002",
                    title: "Generic types are not supported",
                    messageFormat: "Source generator does not support generic types yet: '{0}'.",
                    category: "OTFontFile2.Generators",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true),
                Location.None,
                info.HintName));
            return;
        }

        if (info.Type.IsRecord || info.ContainingTypes.Any(static t => t.IsRecord))
        {
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    id: "OTFF2SG003",
                    title: "Record types are not supported",
                    messageFormat: "Source generator does not support record types yet: '{0}'.",
                    category: "OTFontFile2.Generators",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true),
                Location.None,
                info.HintName));
            return;
        }

        if (info.ContainingTypes.Any(static t => !t.IsPartial))
        {
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    id: "OTFF2SG004",
                    title: "Containing type must be partial",
                    messageFormat: "All containing types must be partial for nested generation: '{0}'.",
                    category: "OTFontFile2.Generators",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true),
                Location.None,
                info.HintName));
            return;
        }

        if (info.Kind == TableKind.Table && info.Tag.Length != 4)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    id: "OTFF2SG001",
                    title: "Invalid OpenType tag",
                    messageFormat: "OtTable tag '{0}' must be exactly 4 characters.",
                    category: "OTFontFile2.Generators",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true),
                Location.None,
                info.Tag));
            return;
        }

        if (!info.GenerateStorage && info.GenerateTryCreate)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    id: "OTFF2SG005",
                    title: "GenerateStorage requires custom TryCreate",
                    messageFormat: "GenerateStorage=false requires GenerateTryCreate=false (provide a custom TryCreate). Type: '{0}'.",
                    category: "OTFontFile2.Generators",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true),
                Location.None,
                info.HintName));
            return;
        }

        for (int i = 0; i < info.SequentialRecordArrays.Length; i++)
        {
            var a = info.SequentialRecordArrays[i];
            if (a.ErrorMessage is null)
                continue;

            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    id: "OTFF2SG006",
                    title: "Invalid sequential record array",
                    messageFormat: "OtSequentialRecordArray on '{0}' is invalid: {1}",
                    category: "OTFontFile2.Generators",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true),
                Location.None,
                info.HintName,
                a.ErrorMessage));
        }

        for (int i = 0; i < info.TagOffsetRecordArrays.Length; i++)
        {
            var a = info.TagOffsetRecordArrays[i];
            if (a.ErrorMessage is null)
                continue;

            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    id: "OTFF2SG010",
                    title: "Invalid tag+offset record array",
                    messageFormat: "OtTagOffsetRecordArray on '{0}' is invalid: {1}",
                    category: "OTFontFile2.Generators",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true),
                Location.None,
                info.HintName,
                a.ErrorMessage));
        }

        for (int i = 0; i < info.SubTableOffsets.Length; i++)
        {
            var o = info.SubTableOffsets[i];
            if (o.ErrorMessage is null)
                continue;

            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    id: "OTFF2SG008",
                    title: "Invalid subtable offset accessor",
                    messageFormat: "OtSubTableOffset on '{0}' is invalid: {1}",
                    category: "OTFontFile2.Generators",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true),
                Location.None,
                info.HintName,
                o.ErrorMessage));
        }

        for (int i = 0; i < info.SubTableOffsetArrays.Length; i++)
        {
            var o = info.SubTableOffsetArrays[i];
            if (o.ErrorMessage is null)
                continue;

            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    id: "OTFF2SG009",
                    title: "Invalid subtable offset array accessor",
                    messageFormat: "OtSubTableOffsetArray on '{0}' is invalid: {1}",
                    category: "OTFontFile2.Generators",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true),
                Location.None,
                info.HintName,
                o.ErrorMessage));
        }

        ValidateMinLengthForGeneratedFields(context, info);
        info = ValidateDiscriminatedUnion(context, info);

        context.AddSource($"{info.HintName}.View.g.cs", SourceText.From(GenerateTableView(info), Encoding.UTF8));

        if (info.Kind == TableKind.Table && info.GenerateBuilder)
        {
            string builderName = string.IsNullOrWhiteSpace(info.BuilderName) ? info.Type.Name + "Builder" : info.BuilderName!;
            context.AddSource($"{builderName}.g.cs", SourceText.From(GenerateTableBuilder(info, builderName), Encoding.UTF8));
        }
    }

    private static TableInfo ValidateDiscriminatedUnion(SourceProductionContext context, TableInfo info)
    {
        var union = info.DiscriminatedUnion;
        if (union is null)
            return info;

        bool ok = true;

        void ReportUnionError(string message)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    id: "OTFF2SG011",
                    title: "Invalid discriminated union",
                    messageFormat: "Discriminated union on '{0}' is invalid: {1}",
                    category: "OTFontFile2.Generators",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true),
                Location.None,
                info.HintName,
                message));
        }

        void ReportCaseError(string caseName, string message)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    id: "OTFF2SG012",
                    title: "Invalid discriminated union case",
                    messageFormat: "OtCase '{0}' on '{1}' is invalid: {2}",
                    category: "OTFontFile2.Generators",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true),
                Location.None,
                caseName,
                info.HintName,
                message));
        }

        if (union.ErrorMessage is not null)
        {
            ReportUnionError(union.ErrorMessage);
            ok = false;
        }

        string? fieldName = union.DiscriminantFieldName;
        if (string.IsNullOrWhiteSpace(fieldName))
        {
            ReportUnionError("DiscriminantFieldName cannot be empty.");
            ok = false;
        }

        FieldInfo? discriminantField = null;
        if (fieldName is not null)
        {
            for (int i = 0; i < info.Fields.Length; i++)
            {
                var field = info.Fields[i];
                if (field.InView && field.Name == fieldName)
                {
                    discriminantField = field;
                    break;
                }
            }

            if (discriminantField is null)
            {
                ReportUnionError($"Discriminant field '{fieldName}' was not found as an [OtField] with InView=true.");
                ok = false;
            }
            else if (!IsSupportedDiscriminantKind(discriminantField.Kind))
            {
                ReportUnionError($"Discriminant field '{fieldName}' must be an integer OtFieldKind (was {discriminantField.Kind}).");
                ok = false;
            }
        }

        if (union.Cases.IsDefaultOrEmpty)
        {
            ReportUnionError("At least one [OtCase] is required.");
            ok = false;
        }

        var seenValues = new HashSet<int>();
        var seenNames = new HashSet<string>(StringComparer.Ordinal);
        for (int i = 0; i < union.Cases.Length; i++)
        {
            var c = union.Cases[i];
            if (c.ErrorMessage is not null)
            {
                ReportCaseError(string.IsNullOrWhiteSpace(c.Name) ? "?" : c.Name, c.ErrorMessage);
                ok = false;
                continue;
            }

            if (!seenValues.Add(c.Value))
            {
                ReportCaseError(c.Name, $"Duplicate case value '{c.Value}'.");
                ok = false;
            }

            if (!seenNames.Add(c.Name))
            {
                ReportCaseError(c.Name, $"Duplicate case name '{c.Name}'.");
                ok = false;
            }

            if (c.VariantKind == CaseVariantKind.Unknown)
            {
                ReportCaseError(c.Name, "VariantKind could not be determined (missing [OtTable]/[OtSubTable]).");
                ok = false;
            }

            if (info.Kind == TableKind.SubTable && c.VariantKind == CaseVariantKind.Table)
            {
                ReportCaseError(c.Name, "VariantType marked as [OtTable] is not supported when the discriminated union is on an [OtSubTable].");
                ok = false;
            }

            if (discriminantField is not null && IsSupportedDiscriminantKind(discriminantField.Kind))
            {
                if (!IsDiscriminantValueInRange(discriminantField.Kind, c.Value))
                {
                    ReportCaseError(c.Name, $"Value '{c.Value}' does not fit discriminant kind {discriminantField.Kind}.");
                    ok = false;
                }
            }
        }

        if (!ok)
            return info with { DiscriminatedUnion = null };

        return info;
    }

    private static void ValidateMinLengthForGeneratedFields(SourceProductionContext context, TableInfo info)
    {
        if (info.MinLength < 0)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    id: "OTFF2SG007",
                    title: "Invalid minLength",
                    messageFormat: "minLength must be >= 0. Type '{0}' minLength was {1}.",
                    category: "OTFontFile2.Generators",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true),
                Location.None,
                info.HintName,
                info.MinLength));
            return;
        }

        int required = 0;
        string? exampleField = null;

        for (int i = 0; i < info.Fields.Length; i++)
        {
            var field = info.Fields[i];
            if (!field.InView)
                continue;

            if (field.Offset < 0)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        id: "OTFF2SG007",
                        title: "Invalid field offset",
                        messageFormat: "Generated field '{0}' on '{1}' has a negative offset ({2}).",
                        category: "OTFontFile2.Generators",
                        DiagnosticSeverity.Error,
                        isEnabledByDefault: true),
                    Location.None,
                    field.Name,
                    info.HintName,
                    field.Offset));
                return;
            }

            int size = GetFieldSizeInBytes(field);
            if (size <= 0)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        id: "OTFF2SG007",
                        title: "Invalid field size",
                        messageFormat: "Generated field '{0}' on '{1}' has an invalid size (kind {2}, length {3}).",
                        category: "OTFontFile2.Generators",
                        DiagnosticSeverity.Error,
                        isEnabledByDefault: true),
                    Location.None,
                    field.Name,
                    info.HintName,
                    field.Kind,
                    field.Length));
                return;
            }

            int end;
            try
            {
                end = checked(field.Offset + size);
            }
            catch (OverflowException)
            {
                context.ReportDiagnostic(Diagnostic.Create(
                    new DiagnosticDescriptor(
                        id: "OTFF2SG007",
                        title: "Invalid field range",
                        messageFormat: "Generated field '{0}' on '{1}' has an invalid range (offset {2} + size {3}).",
                        category: "OTFontFile2.Generators",
                        DiagnosticSeverity.Error,
                        isEnabledByDefault: true),
                    Location.None,
                    field.Name,
                    info.HintName,
                    field.Offset,
                    size));
                return;
            }

            if (end > required)
            {
                required = end;
                exampleField = field.Name;
            }
        }

        if (required > info.MinLength)
        {
            context.ReportDiagnostic(Diagnostic.Create(
                new DiagnosticDescriptor(
                    id: "OTFF2SG007",
                    title: "minLength too small for generated fields",
                    messageFormat: "Type '{0}' declares minLength {1}, but generated fields require at least {2} bytes (e.g. '{3}').",
                    category: "OTFontFile2.Generators",
                    DiagnosticSeverity.Error,
                    isEnabledByDefault: true),
                Location.None,
                info.HintName,
                info.MinLength,
                required,
                exampleField ?? "?"));
        }
    }

    private static int GetFieldSizeInBytes(FieldInfo field) => field.Kind switch
    {
        OtFieldKind.UInt16 or OtFieldKind.Int16 => 2,
        OtFieldKind.UInt24 => 3,
        OtFieldKind.UInt32 or OtFieldKind.Int32 or OtFieldKind.Fixed1616 or OtFieldKind.Tag => 4,
        OtFieldKind.UInt64 or OtFieldKind.Int64 => 8,
        OtFieldKind.Byte or OtFieldKind.SByte => 1,
        OtFieldKind.Bytes => field.Length,
        _ => 0
    };

    private static string GenerateTableView(TableInfo info)
    {
        var fields = info.Fields
            .Where(static f => f.InView)
            .OrderBy(static f => f.Offset)
            .ToArray();

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"namespace {info.Namespace};");
        sb.AppendLine();

        static void AppendIndent(StringBuilder sb, int level)
        {
            for (int i = 0; i < level; i++)
                sb.Append("    ");
        }

        static string GetAccessibilityKeyword(Accessibility accessibility) => accessibility switch
        {
            Accessibility.Public => "public",
            Accessibility.Internal => "internal",
            Accessibility.Private => "private",
            Accessibility.Protected => "protected",
            Accessibility.ProtectedAndInternal => "private protected",
            Accessibility.ProtectedOrInternal => "protected internal",
            _ => "internal"
        };

        static void AppendTypeDeclaration(StringBuilder sb, TypeInfo type, int indentLevel)
        {
            AppendIndent(sb, indentLevel);
            sb.Append(GetAccessibilityKeyword(type.Accessibility));
            sb.Append(' ');

            switch (type.TypeKind)
            {
                case TypeKind.Struct:
                    if (type.IsReadOnly)
                        sb.Append("readonly ");
                    if (type.IsRefLike)
                        sb.Append("ref ");
                    sb.Append("partial struct ");
                    sb.Append(type.Name);
                    break;

                case TypeKind.Class:
                    if (type.IsStatic)
                        sb.Append("static ");
                    sb.Append("partial class ");
                    sb.Append(type.Name);
                    break;

                default:
                    sb.Append("partial struct ");
                    sb.Append(type.Name);
                    break;
            }

            sb.AppendLine();
        }

        static void AppendLine(StringBuilder sb, int indentLevel, string line)
        {
            AppendIndent(sb, indentLevel);
            sb.AppendLine(line);
        }

        int indent = 0;
        foreach (var container in info.ContainingTypes)
        {
            AppendTypeDeclaration(sb, container, indent);
            AppendLine(sb, indent, "{");
            indent++;
        }

        AppendTypeDeclaration(sb, info.Type, indent);
        AppendLine(sb, indent, "{");
        indent++;

        if (info.Kind == TableKind.Table)
        {
            if (info.GenerateStorage)
            {
                AppendLine(sb, indent, "private readonly TableSlice _table;");
                sb.AppendLine();
                AppendLine(sb, indent, $"private {info.Type.Name}(TableSlice table) => _table = table;");
                sb.AppendLine();
                if (info.GenerateTryCreate)
                {
                    AppendLine(sb, indent, $"public static bool TryCreate(TableSlice table, out {info.Type.Name} value)");
                    AppendLine(sb, indent, "{");
                    AppendLine(sb, indent + 1, $"if (table.Length < {info.MinLength})");
                    AppendLine(sb, indent + 1, "{");
                    AppendLine(sb, indent + 2, "value = default;");
                    AppendLine(sb, indent + 2, "return false;");
                    AppendLine(sb, indent + 1, "}");
                    sb.AppendLine();
                    AppendLine(sb, indent + 1, $"value = new {info.Type.Name}(table);");
                    AppendLine(sb, indent + 1, "return true;");
                    AppendLine(sb, indent, "}");
                    sb.AppendLine();
                }
            }
            AppendLine(sb, indent, "public TableSlice Table => _table;");
            sb.AppendLine();

            foreach (var field in fields)
            {
                string propertyType = GetViewPropertyType(field);
                string readExpr = GetViewReadExpression(field, baseOffsetExpr: null);
                AppendLine(sb, indent, $"public {propertyType} {field.Name} => {readExpr};");
            }

            AppendSubTableOffsets(sb, indent, info, baseOffsetExpr: null);
            AppendTagOffsetRecordArrays(sb, indent, info, baseOffsetExpr: null);
            AppendUInt16Arrays(sb, indent, info, baseOffsetExpr: null);
            AppendUInt32Arrays(sb, indent, info, baseOffsetExpr: null);
            AppendSubTableOffsetArrays(sb, indent, info, baseOffsetExpr: null);
            AppendSequentialRecordArrays(sb, indent, info, baseOffsetExpr: null);
            AppendDiscriminatedUnion(sb, indent, info, baseOffsetExpr: null);
        }
        else if (info.Kind == TableKind.SubTable)
        {
            if (info.GenerateStorage)
            {
                AppendLine(sb, indent, "private readonly TableSlice _table;");
                AppendLine(sb, indent, "private readonly int _offset;");
                sb.AppendLine();
                AppendLine(sb, indent, $"private {info.Type.Name}(TableSlice table, int offset)");
                AppendLine(sb, indent, "{");
                AppendLine(sb, indent + 1, "_table = table;");
                AppendLine(sb, indent + 1, "_offset = offset;");
                AppendLine(sb, indent, "}");
                sb.AppendLine();
                if (info.GenerateTryCreate)
                {
                    AppendLine(sb, indent, $"public static bool TryCreate(TableSlice table, int offset, out {info.Type.Name} value)");
                    AppendLine(sb, indent, "{");
                    AppendLine(sb, indent + 1, $"if (table.Length < {info.MinLength} || (uint)offset > (uint)(table.Length - {info.MinLength}))");
                    AppendLine(sb, indent + 1, "{");
                    AppendLine(sb, indent + 2, "value = default;");
                    AppendLine(sb, indent + 2, "return false;");
                    AppendLine(sb, indent + 1, "}");
                    sb.AppendLine();
                    AppendLine(sb, indent + 1, $"value = new {info.Type.Name}(table, offset);");
                    AppendLine(sb, indent + 1, "return true;");
                    AppendLine(sb, indent, "}");
                    sb.AppendLine();
                }
            }
            AppendLine(sb, indent, "public TableSlice Table => _table;");
            AppendLine(sb, indent, "public int Offset => _offset;");
            sb.AppendLine();

            foreach (var field in fields)
            {
                string propertyType = GetViewPropertyType(field);
                string readExpr = GetViewReadExpression(field, baseOffsetExpr: "_offset");
                AppendLine(sb, indent, $"public {propertyType} {field.Name} => {readExpr};");
            }

            AppendSubTableOffsets(sb, indent, info, baseOffsetExpr: "_offset");
            AppendTagOffsetRecordArrays(sb, indent, info, baseOffsetExpr: "_offset");
            AppendUInt16Arrays(sb, indent, info, baseOffsetExpr: "_offset");
            AppendUInt32Arrays(sb, indent, info, baseOffsetExpr: "_offset");
            AppendSubTableOffsetArrays(sb, indent, info, baseOffsetExpr: "_offset");
            AppendSequentialRecordArrays(sb, indent, info, baseOffsetExpr: "_offset");
            AppendDiscriminatedUnion(sb, indent, info, baseOffsetExpr: "_offset");
        }

        indent--;
        AppendLine(sb, indent, "}");

        for (int i = info.ContainingTypes.Length - 1; i >= 0; i--)
        {
            indent--;
            AppendLine(sb, indent, "}");
        }

        return sb.ToString();
    }

    private static void AppendSubTableOffsets(StringBuilder sb, int indent, TableInfo info, string? baseOffsetExpr)
    {
        if (info.SubTableOffsets.IsDefaultOrEmpty)
            return;

        static void AppendIndent(StringBuilder sb, int level)
        {
            for (int i = 0; i < level; i++)
                sb.Append("    ");
        }

        static void AppendLine(StringBuilder sb, int indentLevel, string line)
        {
            AppendIndent(sb, indentLevel);
            sb.AppendLine(line);
        }

        for (int i = 0; i < info.SubTableOffsets.Length; i++)
        {
            var o = info.SubTableOffsets[i];
            if (o.ErrorMessage is not null)
                continue;

            string name = o.Name;
            if (string.IsNullOrWhiteSpace(name))
                continue;

            string methodName = "TryGet" + name;
            string defaultOutName = char.ToLowerInvariant(name[0]) + name.Substring(1);
            string outName = EscapeIdentifier(o.OutParameterName ?? defaultOutName);

            string baseExpr = o.RelativeToTableStart ? "0" : (baseOffsetExpr ?? "0");
            string typeName = o.SubTableTypeName;

            AppendLine(sb, indent, string.Empty);
            AppendLine(sb, indent, $"public bool {methodName}(out {typeName} {outName})");
            AppendLine(sb, indent, "{");
            AppendLine(sb, indent + 1, $"{outName} = default;");
            sb.AppendLine();
            AppendLine(sb, indent + 1, $"uint rel = {o.OffsetPropertyName};");
            AppendLine(sb, indent + 1, "if (rel == 0)");
            AppendLine(sb, indent + 2, "return false;");
            sb.AppendLine();
            AppendLine(sb, indent + 1, $"long offsetLong = (long){baseExpr} + rel;");
            AppendLine(sb, indent + 1, "if (offsetLong > int.MaxValue)");
            AppendLine(sb, indent + 2, "return false;");
            sb.AppendLine();
            AppendLine(sb, indent + 1, "int offset = (int)offsetLong;");
            AppendLine(sb, indent + 1, $"return {typeName}.TryCreate(_table, offset, out {outName});");
            AppendLine(sb, indent, "}");
        }
    }

    private static void AppendSubTableOffsetArrays(StringBuilder sb, int indent, TableInfo info, string? baseOffsetExpr)
    {
        if (info.SubTableOffsetArrays.IsDefaultOrEmpty)
            return;

        static void AppendIndent(StringBuilder sb, int level)
        {
            for (int i = 0; i < level; i++)
                sb.Append("    ");
        }

        static void AppendLine(StringBuilder sb, int indentLevel, string line)
        {
            AppendIndent(sb, indentLevel);
            sb.AppendLine(line);
        }

        for (int i = 0; i < info.SubTableOffsetArrays.Length; i++)
        {
            var o = info.SubTableOffsetArrays[i];
            if (o.ErrorMessage is not null)
                continue;

            string name = o.Name;
            if (string.IsNullOrWhiteSpace(name))
                continue;

            string offsetArrayName = o.OffsetArrayName;
            if (string.IsNullOrWhiteSpace(offsetArrayName))
                continue;

            string methodName = "TryGet" + name;
            string offsetMethodName = "TryGet" + offsetArrayName;
            string defaultOutName = char.ToLowerInvariant(name[0]) + name.Substring(1);
            string outName = EscapeIdentifier(o.OutParameterName ?? defaultOutName);

            string baseExpr = o.RelativeToTableStart ? "0" : (baseOffsetExpr ?? "0");
            string typeName = o.SubTableTypeName;

            bool foundU16 = false;
            for (int a = 0; a < info.UInt16Arrays.Length; a++)
            {
                if (info.UInt16Arrays[a].Name == offsetArrayName)
                {
                    foundU16 = true;
                    break;
                }
            }

            string relType = foundU16 ? "ushort" : "uint";

            AppendLine(sb, indent, string.Empty);
            AppendLine(sb, indent, $"public bool {methodName}(int index, out {typeName} {outName})");
            AppendLine(sb, indent, "{");
            AppendLine(sb, indent + 1, $"{outName} = default;");
            sb.AppendLine();
            AppendLine(sb, indent + 1, $"if (!{offsetMethodName}(index, out {relType} rel) || rel == 0)");
            AppendLine(sb, indent + 2, "return false;");
            sb.AppendLine();
            AppendLine(sb, indent + 1, $"long offsetLong = (long){baseExpr} + rel;");
            AppendLine(sb, indent + 1, "if (offsetLong > int.MaxValue)");
            AppendLine(sb, indent + 2, "return false;");
            sb.AppendLine();
            AppendLine(sb, indent + 1, "int offset = (int)offsetLong;");
            AppendLine(sb, indent + 1, $"return {typeName}.TryCreate(_table, offset, out {outName});");
            AppendLine(sb, indent, "}");
        }
    }

    private static void AppendTagOffsetRecordArrays(StringBuilder sb, int indent, TableInfo info, string? baseOffsetExpr)
    {
        if (info.TagOffsetRecordArrays.IsDefaultOrEmpty)
            return;

        static void AppendIndent(StringBuilder sb, int level)
        {
            for (int i = 0; i < level; i++)
                sb.Append("    ");
        }

        static void AppendLine(StringBuilder sb, int indentLevel, string line)
        {
            AppendIndent(sb, indentLevel);
            sb.AppendLine(line);
        }

        for (int i = 0; i < info.TagOffsetRecordArrays.Length; i++)
        {
            var a = info.TagOffsetRecordArrays[i];

            string name = a.Name;
            if (string.IsNullOrWhiteSpace(name))
                continue;

            string countPropertyName = a.CountPropertyName ?? (name + "Count");
            int recordSize = a.Offset32 ? 8 : 6;
            string offsetType = a.Offset32 ? "uint" : "ushort";

            AppendLine(sb, indent, string.Empty);
            AppendLine(sb, indent, $"public readonly struct {name}Record");
            AppendLine(sb, indent, "{");
            AppendLine(sb, indent + 1, $"public Tag {name}Tag {{ get; }}");
            AppendLine(sb, indent + 1, $"public {offsetType} {name}Offset {{ get; }}");
            sb.AppendLine();
            AppendLine(sb, indent + 1, $"public {name}Record(Tag {char.ToLowerInvariant(name[0])}{name.Substring(1)}Tag, {offsetType} {char.ToLowerInvariant(name[0])}{name.Substring(1)}Offset)");
            AppendLine(sb, indent + 1, "{");
            AppendLine(sb, indent + 2, $"{name}Tag = {char.ToLowerInvariant(name[0])}{name.Substring(1)}Tag;");
            AppendLine(sb, indent + 2, $"{name}Offset = {char.ToLowerInvariant(name[0])}{name.Substring(1)}Offset;");
            AppendLine(sb, indent + 1, "}");
            AppendLine(sb, indent, "}");
            sb.AppendLine();

            string recordTypeName = $"{name}Record";
            string methodName = $"TryGet{name}Record";
            string basePrefix = baseOffsetExpr is null ? string.Empty : baseOffsetExpr + " + ";

            AppendLine(sb, indent, $"public bool {methodName}(int index, out {recordTypeName} record)");
            AppendLine(sb, indent, "{");
            AppendLine(sb, indent + 1, "record = default;");
            sb.AppendLine();
            AppendLine(sb, indent + 1, $"ushort count = {countPropertyName};");
            AppendLine(sb, indent + 1, "if ((uint)index >= (uint)count)");
            AppendLine(sb, indent + 2, "return false;");
            sb.AppendLine();
            AppendLine(sb, indent + 1, $"long offsetLong = (long){basePrefix}{a.RecordsOffset} + ((long)index * {recordSize});");
            AppendLine(sb, indent + 1, $"if (offsetLong < 0 || offsetLong > (long)_table.Length - {recordSize})");
            AppendLine(sb, indent + 2, "return false;");
            AppendLine(sb, indent + 1, "int offset = (int)offsetLong;");
            sb.AppendLine();
            AppendLine(sb, indent + 1, "var data = _table.Span;");
            AppendLine(sb, indent + 1, $"record = new {recordTypeName}(");
            AppendLine(sb, indent + 2, $"{char.ToLowerInvariant(name[0])}{name.Substring(1)}Tag: new Tag(BigEndian.ReadUInt32(data, offset)),");
            AppendLine(sb, indent + 2, a.Offset32
                ? $"{char.ToLowerInvariant(name[0])}{name.Substring(1)}Offset: BigEndian.ReadUInt32(data, offset + 4));"
                : $"{char.ToLowerInvariant(name[0])}{name.Substring(1)}Offset: BigEndian.ReadUInt16(data, offset + 4));");
            AppendLine(sb, indent + 1, "return true;");
            AppendLine(sb, indent, "}");

            string findRecordMethodName = $"TryFind{name}Record";
            string tagParamName = char.ToLowerInvariant(name[0]) + name.Substring(1) + "Tag";

            AppendLine(sb, indent, string.Empty);
            AppendLine(sb, indent, $"public bool {findRecordMethodName}(Tag {tagParamName}, out {recordTypeName} record)");
            AppendLine(sb, indent, "{");
            AppendLine(sb, indent + 1, "record = default;");
            sb.AppendLine();
            AppendLine(sb, indent + 1, $"ushort count = {countPropertyName};");
            AppendLine(sb, indent + 1, "if (count == 0)");
            AppendLine(sb, indent + 2, "return false;");
            sb.AppendLine();
            AppendLine(sb, indent + 1, $"long recordsOffsetLong = (long){basePrefix}{a.RecordsOffset};");
            AppendLine(sb, indent + 1, $"long bytesNeeded = (long)count * {recordSize};");
            AppendLine(sb, indent + 1, "if (recordsOffsetLong < 0 || recordsOffsetLong > (long)_table.Length - bytesNeeded)");
            AppendLine(sb, indent + 2, "return false;");
            sb.AppendLine();
            AppendLine(sb, indent + 1, "int recordsOffset = (int)recordsOffsetLong;");
            AppendLine(sb, indent + 1, "uint target = " + tagParamName + ".Value;");
            AppendLine(sb, indent + 1, "var data = _table.Span;");
            sb.AppendLine();
            AppendLine(sb, indent + 1, "int lo = 0;");
            AppendLine(sb, indent + 1, "int hi = count - 1;");
            AppendLine(sb, indent + 1, "while (lo <= hi)");
            AppendLine(sb, indent + 1, "{");
            AppendLine(sb, indent + 2, "int mid = (lo + hi) >> 1;");
            AppendLine(sb, indent + 2, $"int o = recordsOffset + (mid * {recordSize});");
            AppendLine(sb, indent + 2, "uint midTag = BigEndian.ReadUInt32(data, o);");
            sb.AppendLine();
            AppendLine(sb, indent + 2, "if (target < midTag)");
            AppendLine(sb, indent + 2, "{");
            AppendLine(sb, indent + 3, "hi = mid - 1;");
            AppendLine(sb, indent + 3, "continue;");
            AppendLine(sb, indent + 2, "}");
            sb.AppendLine();
            AppendLine(sb, indent + 2, "if (target > midTag)");
            AppendLine(sb, indent + 2, "{");
            AppendLine(sb, indent + 3, "lo = mid + 1;");
            AppendLine(sb, indent + 3, "continue;");
            AppendLine(sb, indent + 2, "}");
            sb.AppendLine();
            AppendLine(sb, indent + 2, $"record = new {recordTypeName}(");
            AppendLine(sb, indent + 3, $"{tagParamName}: new Tag(midTag),");
            AppendLine(sb, indent + 3, a.Offset32
                ? $"{char.ToLowerInvariant(name[0])}{name.Substring(1)}Offset: BigEndian.ReadUInt32(data, o + 4));"
                : $"{char.ToLowerInvariant(name[0])}{name.Substring(1)}Offset: BigEndian.ReadUInt16(data, o + 4));");
            AppendLine(sb, indent + 2, "return true;");
            AppendLine(sb, indent + 1, "}");
            sb.AppendLine();
            AppendLine(sb, indent + 1, "// Fallback for malformed fonts that don't keep records sorted.");
            AppendLine(sb, indent + 1, "for (int i = 0; i < count; i++)");
            AppendLine(sb, indent + 1, "{");
            AppendLine(sb, indent + 2, $"int o = recordsOffset + (i * {recordSize});");
            AppendLine(sb, indent + 2, "uint t = BigEndian.ReadUInt32(data, o);");
            AppendLine(sb, indent + 2, "if (t != target)");
            AppendLine(sb, indent + 3, "continue;");
            sb.AppendLine();
            AppendLine(sb, indent + 2, $"record = new {recordTypeName}(");
            AppendLine(sb, indent + 3, $"{tagParamName}: new Tag(t),");
            AppendLine(sb, indent + 3, a.Offset32
                ? $"{char.ToLowerInvariant(name[0])}{name.Substring(1)}Offset: BigEndian.ReadUInt32(data, o + 4));"
                : $"{char.ToLowerInvariant(name[0])}{name.Substring(1)}Offset: BigEndian.ReadUInt16(data, o + 4));");
            AppendLine(sb, indent + 2, "return true;");
            AppendLine(sb, indent + 1, "}");
            sb.AppendLine();
            AppendLine(sb, indent + 1, "return false;");
            AppendLine(sb, indent, "}");

            if (a.ErrorMessage is not null || string.IsNullOrWhiteSpace(a.SubTableTypeName))
                continue;

            string resolverMethodName = "TryGet" + name;
            string resolverDefaultOutName = char.ToLowerInvariant(name[0]) + name.Substring(1);
            string resolverOutName = EscapeIdentifier(a.OutParameterName ?? resolverDefaultOutName);
            string subTableTypeName = a.SubTableTypeName!;
            string baseExpr = baseOffsetExpr ?? "0";
            string recordOffsetPropertyName = name + "Offset";

            AppendLine(sb, indent, string.Empty);
            AppendLine(sb, indent, $"public bool {resolverMethodName}({recordTypeName} record, out {subTableTypeName} {resolverOutName})");
            AppendLine(sb, indent, "{");
            AppendLine(sb, indent + 1, $"{resolverOutName} = default;");
            sb.AppendLine();
            AppendLine(sb, indent + 1, $"uint rel = record.{recordOffsetPropertyName};");
            AppendLine(sb, indent + 1, "if (rel == 0)");
            AppendLine(sb, indent + 2, "return false;");
            sb.AppendLine();
            AppendLine(sb, indent + 1, $"long offsetLong = (long){baseExpr} + rel;");
            AppendLine(sb, indent + 1, "if (offsetLong > int.MaxValue)");
            AppendLine(sb, indent + 2, "return false;");
            sb.AppendLine();
            AppendLine(sb, indent + 1, "int offset = (int)offsetLong;");
            AppendLine(sb, indent + 1, $"return {subTableTypeName}.TryCreate(_table, offset, out {resolverOutName});");
            AppendLine(sb, indent, "}");

            AppendLine(sb, indent, string.Empty);
            AppendLine(sb, indent, $"public bool {resolverMethodName}(int index, out {subTableTypeName} {resolverOutName})");
            AppendLine(sb, indent, "{");
            AppendLine(sb, indent + 1, $"{resolverOutName} = default;");
            AppendLine(sb, indent + 1, $"return {methodName}(index, out var record) && {resolverMethodName}(record, out {resolverOutName});");
            AppendLine(sb, indent, "}");

            string findResolverMethodName = "TryFind" + name;
            AppendLine(sb, indent, string.Empty);
            AppendLine(sb, indent, $"public bool {findResolverMethodName}(Tag {tagParamName}, out {subTableTypeName} {resolverOutName})");
            AppendLine(sb, indent, "{");
            AppendLine(sb, indent + 1, $"{resolverOutName} = default;");
            AppendLine(sb, indent + 1, $"return {findRecordMethodName}({tagParamName}, out var record) && {resolverMethodName}(record, out {resolverOutName});");
            AppendLine(sb, indent, "}");
        }
    }

    private static void AppendUInt16Arrays(StringBuilder sb, int indent, TableInfo info, string? baseOffsetExpr)
    {
        if (info.UInt16Arrays.IsDefaultOrEmpty)
            return;

        static void AppendIndent(StringBuilder sb, int level)
        {
            for (int i = 0; i < level; i++)
                sb.Append("    ");
        }

        static void AppendLine(StringBuilder sb, int indentLevel, string line)
        {
            AppendIndent(sb, indentLevel);
            sb.AppendLine(line);
        }

        for (int i = 0; i < info.UInt16Arrays.Length; i++)
        {
            var a = info.UInt16Arrays[i];

            string name = a.Name;
            if (string.IsNullOrWhiteSpace(name))
                continue;

            string countPropertyName = a.CountPropertyName ?? (name + "Count");
            string methodName = $"TryGet{name}";
            string defaultOutName = char.ToLowerInvariant(name[0]) + name.Substring(1);
            string outName = EscapeIdentifier(a.OutParameterName ?? defaultOutName);

            string basePrefix = baseOffsetExpr ?? "0";
            string valuesOffsetExpr = a.ValuesOffsetExpression ?? a.ValuesOffset.ToString();
            string? boundsLenExpr = a.BoundsLengthExpression;

            AppendLine(sb, indent, string.Empty);
            AppendLine(sb, indent, $"public bool {methodName}(int index, out ushort {outName})");
            AppendLine(sb, indent, "{");
            AppendLine(sb, indent + 1, $"{outName} = 0;");
            sb.AppendLine();
            if (a.CountAdjustment == 0)
            {
                AppendLine(sb, indent + 1, $"ushort count = {countPropertyName};");
                AppendLine(sb, indent + 1, "if ((uint)index >= (uint)count)");
                AppendLine(sb, indent + 2, "return false;");
                sb.AppendLine();
            }
            else
            {
                AppendLine(sb, indent + 1, $"ushort rawCount = {countPropertyName};");
                AppendLine(sb, indent + 1, $"int count = rawCount + ({a.CountAdjustment});");
                AppendLine(sb, indent + 1, "if (count < 0)");
                AppendLine(sb, indent + 2, "return false;");
                AppendLine(sb, indent + 1, "if ((uint)index >= (uint)count)");
                AppendLine(sb, indent + 2, "return false;");
                sb.AppendLine();
            }
            AppendLine(sb, indent + 1, $"long offsetLong = (long){basePrefix} + ({valuesOffsetExpr}) + ((long)index * 2);");
            AppendLine(sb, indent + 1, "if (offsetLong < 0 || offsetLong > (long)_table.Length - 2)");
            AppendLine(sb, indent + 2, "return false;");
            if (boundsLenExpr is not null)
            {
                AppendLine(sb, indent + 1, $"if (offsetLong > (long){basePrefix} + ({boundsLenExpr}) - 2)");
                AppendLine(sb, indent + 2, "return false;");
            }
            AppendLine(sb, indent + 1, "int offset = (int)offsetLong;");
            sb.AppendLine();
            AppendLine(sb, indent + 1, $"{outName} = BigEndian.ReadUInt16(_table.Span, offset);");
            AppendLine(sb, indent + 1, "return true;");
            AppendLine(sb, indent, "}");
        }
    }

    private static void AppendUInt32Arrays(StringBuilder sb, int indent, TableInfo info, string? baseOffsetExpr)
    {
        if (info.UInt32Arrays.IsDefaultOrEmpty)
            return;

        static void AppendIndent(StringBuilder sb, int level)
        {
            for (int i = 0; i < level; i++)
                sb.Append("    ");
        }

        static void AppendLine(StringBuilder sb, int indentLevel, string line)
        {
            AppendIndent(sb, indentLevel);
            sb.AppendLine(line);
        }

        for (int i = 0; i < info.UInt32Arrays.Length; i++)
        {
            var a = info.UInt32Arrays[i];

            string name = a.Name;
            if (string.IsNullOrWhiteSpace(name))
                continue;

            string countPropertyName = a.CountPropertyName ?? (name + "Count");
            string methodName = $"TryGet{name}";
            string defaultOutName = char.ToLowerInvariant(name[0]) + name.Substring(1);
            string outName = EscapeIdentifier(a.OutParameterName ?? defaultOutName);

            string basePrefix = baseOffsetExpr ?? "0";
            string valuesOffsetExpr = a.ValuesOffsetExpression ?? a.ValuesOffset.ToString();
            string? boundsLenExpr = a.BoundsLengthExpression;

            AppendLine(sb, indent, string.Empty);
            AppendLine(sb, indent, $"public bool {methodName}(int index, out uint {outName})");
            AppendLine(sb, indent, "{");
            AppendLine(sb, indent + 1, $"{outName} = 0;");
            sb.AppendLine();
            if (a.CountAdjustment == 0)
            {
                AppendLine(sb, indent + 1, $"uint count = {countPropertyName};");
                AppendLine(sb, indent + 1, "if ((uint)index >= count)");
                AppendLine(sb, indent + 2, "return false;");
                sb.AppendLine();
            }
            else
            {
                AppendLine(sb, indent + 1, $"uint rawCount = {countPropertyName};");
                AppendLine(sb, indent + 1, $"long countLong = (long)rawCount + ({a.CountAdjustment});");
                AppendLine(sb, indent + 1, "if (countLong < 0)");
                AppendLine(sb, indent + 2, "return false;");
                AppendLine(sb, indent + 1, "if ((ulong)(uint)index >= (ulong)countLong)");
                AppendLine(sb, indent + 2, "return false;");
                sb.AppendLine();
            }
            AppendLine(sb, indent + 1, $"long offsetLong = (long){basePrefix} + ({valuesOffsetExpr}) + ((long)index * 4);");
            AppendLine(sb, indent + 1, "if (offsetLong < 0 || offsetLong > (long)_table.Length - 4)");
            AppendLine(sb, indent + 2, "return false;");
            if (boundsLenExpr is not null)
            {
                AppendLine(sb, indent + 1, $"if (offsetLong > (long){basePrefix} + ({boundsLenExpr}) - 4)");
                AppendLine(sb, indent + 2, "return false;");
            }
            AppendLine(sb, indent + 1, "int offset = (int)offsetLong;");
            sb.AppendLine();
            AppendLine(sb, indent + 1, $"{outName} = BigEndian.ReadUInt32(_table.Span, offset);");
            AppendLine(sb, indent + 1, "return true;");
            AppendLine(sb, indent, "}");
        }
    }

    private static void AppendSequentialRecordArrays(StringBuilder sb, int indent, TableInfo info, string? baseOffsetExpr)
    {
        if (info.SequentialRecordArrays.IsDefaultOrEmpty)
            return;

        static void AppendIndent(StringBuilder sb, int level)
        {
            for (int i = 0; i < level; i++)
                sb.Append("    ");
        }

        static void AppendLine(StringBuilder sb, int indentLevel, string line)
        {
            AppendIndent(sb, indentLevel);
            sb.AppendLine(line);
        }

        string basePrefix = baseOffsetExpr ?? "0";

        for (int i = 0; i < info.SequentialRecordArrays.Length; i++)
        {
            var a = info.SequentialRecordArrays[i];
            if (a.ErrorMessage is not null)
                continue;

            string name = a.Name;
            if (string.IsNullOrWhiteSpace(name))
                continue;

            string countPropertyName = a.CountPropertyName ?? (name + "Count");
            string defaultOutName = char.ToLowerInvariant(name[0]) + name.Substring(1);
            string outName = EscapeIdentifier(a.OutParameterName ?? defaultOutName);
            string recordsOffsetExpr = a.RecordsOffsetExpression ?? a.RecordsOffset.ToString();
            string? boundsLenExpr = a.BoundsLengthExpression;
            string strideExpr = a.RecordStrideExpression ?? a.RecordSize.ToString();

            AppendLine(sb, indent, string.Empty);
            AppendLine(sb, indent, $"public bool TryGet{name}(int index, out {a.RecordTypeName} {outName})");
            AppendLine(sb, indent, "{");
            AppendLine(sb, indent + 1, $"{outName} = default;");
            sb.AppendLine();
            AppendLine(sb, indent + 1, $"uint count = {countPropertyName};");
            AppendLine(sb, indent + 1, "if ((uint)index >= count)");
            AppendLine(sb, indent + 2, "return false;");
            sb.AppendLine();
            AppendLine(sb, indent + 1, $"long offsetLong = (long){basePrefix} + ({recordsOffsetExpr}) + ((long)index * ({strideExpr}));");
            AppendLine(sb, indent + 1, $"if (offsetLong < 0 || offsetLong > (long)_table.Length - {a.RecordSize})");
            AppendLine(sb, indent + 2, "return false;");
            if (boundsLenExpr is not null)
            {
                AppendLine(sb, indent + 1, $"if (offsetLong > (long){basePrefix} + ({boundsLenExpr}) - {a.RecordSize})");
                AppendLine(sb, indent + 2, "return false;");
            }
            AppendLine(sb, indent + 1, "int offset = (int)offsetLong;");
            sb.AppendLine();
            AppendLine(sb, indent + 1, "var data = _table.Span;");
            AppendLine(sb, indent + 1, $"{outName} = new {a.RecordTypeName}(");

            for (int f = 0; f < a.Fields.Length; f++)
            {
                var field = a.Fields[f];
                string paramName = EscapeIdentifier(field.ParameterName);
                string expr = field.Kind == SequentialRecordFieldKind.Context
                    ? (field.ContextExpression ?? "default")
                    : GetSequentialRecordReadExpression(field.Kind, $"offset + {field.Offset}", field.CastTypeName);
                string trailing = f == a.Fields.Length - 1 ? ");" : ",";
                AppendLine(sb, indent + 2, $"{paramName}: {expr}{trailing}");
            }

            AppendLine(sb, indent + 1, "return true;");
            AppendLine(sb, indent, "}");
        }
    }

    private static void AppendDiscriminatedUnion(StringBuilder sb, int indent, TableInfo info, string? baseOffsetExpr)
    {
        var union = info.DiscriminatedUnion;
        if (union is null || union.ErrorMessage is not null || union.Cases.IsDefaultOrEmpty)
            return;

        if (string.IsNullOrWhiteSpace(union.DiscriminantFieldName))
            return;

        FieldInfo? discriminantField = null;
        for (int i = 0; i < info.Fields.Length; i++)
        {
            var f = info.Fields[i];
            if (f.InView && f.Name == union.DiscriminantFieldName)
            {
                discriminantField = f;
                break;
            }
        }

        if (discriminantField is null || !IsSupportedDiscriminantKind(discriminantField.Kind))
            return;

        string discriminantName = union.DiscriminantFieldName!;
        string offsetExpr = baseOffsetExpr ?? "0";

        static void AppendIndent(StringBuilder sb, int level)
        {
            for (int i = 0; i < level; i++)
                sb.Append("    ");
        }

        static void AppendLine(StringBuilder sb, int indentLevel, string line)
        {
            AppendIndent(sb, indentLevel);
            sb.AppendLine(line);
        }

        for (int i = 0; i < union.Cases.Length; i++)
        {
            var c = union.Cases[i];
            if (c.ErrorMessage is not null)
                continue;

            string caseName = c.Name;
            if (string.IsNullOrWhiteSpace(caseName))
                continue;

            string typeName = c.VariantTypeName;
            if (string.IsNullOrWhiteSpace(typeName))
                continue;

            if (!TryGetDiscriminantLiteral(discriminantField.Kind, c.Value, out string literal))
                continue;

            string methodName = "TryGet" + caseName;
            string defaultOutName = caseName.Length == 1
                ? caseName.ToLowerInvariant()
                : char.ToLowerInvariant(caseName[0]) + caseName.Substring(1);
            string outName = EscapeIdentifier(c.OutParameterName ?? defaultOutName);

            AppendLine(sb, indent, string.Empty);
            AppendLine(sb, indent, $"public bool {methodName}(out {typeName} {outName})");
            AppendLine(sb, indent, "{");
            AppendLine(sb, indent + 1, $"{outName} = default;");
            sb.AppendLine();
            AppendLine(sb, indent + 1, $"if ({discriminantName} != {literal})");
            AppendLine(sb, indent + 2, "return false;");
            sb.AppendLine();

            switch (c.VariantKind)
            {
                case CaseVariantKind.SubTable:
                    AppendLine(sb, indent + 1, $"return {typeName}.TryCreate(_table, {offsetExpr}, out {outName});");
                    break;

                case CaseVariantKind.Table:
                    if (info.Kind == TableKind.Table)
                        AppendLine(sb, indent + 1, $"return {typeName}.TryCreate(_table, out {outName});");
                    else
                        AppendLine(sb, indent + 1, "return false;");
                    break;

                default:
                    AppendLine(sb, indent + 1, "return false;");
                    break;
            }

            AppendLine(sb, indent, "}");
        }
    }

    private static string GenerateTableBuilder(TableInfo info, string builderName)
    {
        var fields = info.Fields
            .Where(static f => f.InBuilder)
            .OrderBy(static f => f.Offset)
            .ToArray();

        bool isHead = info.Tag == "head";
        uint tagValue = TagToUInt32(info.Tag);

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"namespace {info.Namespace};");
        sb.AppendLine();
        sb.AppendLine($"public sealed partial class {builderName} : ISfntTableSource");
        sb.AppendLine("{");
        sb.AppendLine("    private byte[]? _built;");
        sb.AppendLine("    private uint _checksum;");
        sb.AppendLine("    private bool _dirty = true;");
        sb.AppendLine();

        foreach (var field in fields)
        {
            string fieldType = GetBuilderFieldType(field);
            string fieldName = GetBuilderFieldName(field.Name);

            if (field.Kind == OtFieldKind.Bytes)
            {
                if (field.Length <= 0)
                    continue;

                sb.AppendLine($"    private readonly byte[] {fieldName} = new byte[{field.Length}];");
                continue;
            }

            string initializer = field.HasDefaultValue ? " = " + GetBuilderDefaultValueExpression(field) + ";" : ";";
            sb.AppendLine($"    private {fieldType} {fieldName}{initializer}");
        }

        sb.AppendLine();
        sb.AppendLine($"    public Tag Tag => new(0x{tagValue:X8}u);");
        sb.AppendLine();

        foreach (var field in fields)
        {
            if (field.Kind == OtFieldKind.Bytes)
            {
                if (field.Length <= 0)
                    continue;

                string fieldName = GetBuilderFieldName(field.Name);
                sb.AppendLine($"    public ReadOnlySpan<byte> {field.Name} => {fieldName};");
                sb.AppendLine();
                sb.AppendLine($"    public void Set{field.Name}(ReadOnlySpan<byte> value)");
                sb.AppendLine("    {");
                sb.AppendLine($"        if (value.Length > {field.Length})");
                sb.AppendLine($"            throw new ArgumentOutOfRangeException(nameof(value), $\"Value must be <= {field.Length} bytes.\");");
                sb.AppendLine();
                sb.AppendLine($"        {fieldName}.AsSpan().Fill(0x{field.PadByte:X2});");
                sb.AppendLine($"        value.CopyTo({fieldName});");
                sb.AppendLine("        MarkDirty();");
                sb.AppendLine("    }");
                sb.AppendLine();
                continue;
            }

            string propertyType = GetBuilderPropertyType(field);
            string fieldName2 = GetBuilderFieldName(field.Name);
            sb.AppendLine($"    public {propertyType} {field.Name}");
            sb.AppendLine("    {");
            sb.AppendLine($"        get => {fieldName2};");
            sb.AppendLine("        set");
            sb.AppendLine("        {");
            sb.AppendLine($"            if (value == {fieldName2})");
            sb.AppendLine("                return;");
            sb.AppendLine();
            sb.AppendLine($"            {fieldName2} = value;");
            sb.AppendLine("            MarkDirty();");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        sb.AppendLine($"    public int Length => {info.MinLength};");
        sb.AppendLine();
        sb.AppendLine("    public uint GetDirectoryChecksum()");
        sb.AppendLine("    {");
        sb.AppendLine("        EnsureBuilt();");
        sb.AppendLine("        return _checksum;");
        sb.AppendLine("    }");
        sb.AppendLine();
        if (isHead)
        {
            sb.AppendLine("    public void WriteTo(Stream destination, uint headCheckSumAdjustment)");
            sb.AppendLine("    {");
            sb.AppendLine("        if (destination is null) throw new ArgumentNullException(nameof(destination));");
            sb.AppendLine();
            sb.AppendLine("        var data = EnsureBuilt();");
            sb.AppendLine("        destination.Write(data.AsSpan(0, 8));");
            sb.AppendLine("        Span<byte> adj = stackalloc byte[4];");
            sb.AppendLine("        BigEndian.WriteUInt32(adj, 0, headCheckSumAdjustment);");
            sb.AppendLine("        destination.Write(adj);");
            sb.AppendLine("        destination.Write(data.AsSpan(12));");
            sb.AppendLine("    }");
        }
        else
        {
            sb.AppendLine("    public void WriteTo(Stream destination, uint headCheckSumAdjustment)");
            sb.AppendLine("    {");
            sb.AppendLine("        if (destination is null) throw new ArgumentNullException(nameof(destination));");
            sb.AppendLine("        destination.Write(EnsureBuilt());");
            sb.AppendLine("    }");
        }
        sb.AppendLine();
        sb.AppendLine("    public byte[] ToArray() => EnsureBuilt();");
        sb.AppendLine();
        sb.AppendLine($"    public static bool TryFrom({info.Type.Name} table, out {builderName} builder)");
        sb.AppendLine("    {");
        sb.AppendLine("        builder = null!;");
        sb.AppendLine();
        sb.AppendLine($"        if (table.Table.Length < {info.MinLength})");
        sb.AppendLine("            return false;");
        sb.AppendLine();
        sb.AppendLine($"        builder = new {builderName}();");

        foreach (var field in fields)
        {
            string fieldName = GetBuilderFieldName(field.Name);

            if (field.Kind == OtFieldKind.Bytes)
            {
                if (field.Length <= 0)
                    continue;

                sb.AppendLine($"        table.{field.Name}.CopyTo(builder.{fieldName});");
                continue;
            }

            sb.AppendLine($"        builder.{fieldName} = table.{field.Name};");
        }

        sb.AppendLine();
        sb.AppendLine("        builder.MarkDirty();");
        sb.AppendLine("        return true;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private void MarkDirty()");
        sb.AppendLine("    {");
        sb.AppendLine("        _dirty = true;");
        sb.AppendLine("        _built = null;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    private byte[] EnsureBuilt()");
        sb.AppendLine("    {");
        sb.AppendLine("        if (!_dirty && _built is not null)");
        sb.AppendLine("            return _built;");
        sb.AppendLine();
        sb.AppendLine($"        byte[] table = new byte[{info.MinLength}];");
        sb.AppendLine("        var span = table.AsSpan();");
        sb.AppendLine();

        foreach (var field in fields)
        {
            string fieldName = GetBuilderFieldName(field.Name);

            switch (field.Kind)
            {
                case OtFieldKind.UInt16:
                    sb.AppendLine($"        BigEndian.WriteUInt16(span, {field.Offset}, {field.Name});");
                    break;
                case OtFieldKind.Int16:
                    sb.AppendLine($"        BigEndian.WriteInt16(span, {field.Offset}, {field.Name});");
                    break;
                case OtFieldKind.UInt24:
                    sb.AppendLine($"        BigEndian.WriteUInt24(span, {field.Offset}, {field.Name});");
                    break;
                case OtFieldKind.UInt32:
                    sb.AppendLine($"        BigEndian.WriteUInt32(span, {field.Offset}, {field.Name});");
                    break;
                case OtFieldKind.Int32:
                    sb.AppendLine($"        BigEndian.WriteInt32(span, {field.Offset}, {field.Name});");
                    break;
                case OtFieldKind.UInt64:
                    sb.AppendLine($"        BigEndian.WriteUInt64(span, {field.Offset}, {field.Name});");
                    break;
                case OtFieldKind.Int64:
                    sb.AppendLine($"        BigEndian.WriteInt64(span, {field.Offset}, {field.Name});");
                    break;
                case OtFieldKind.Fixed1616:
                    sb.AppendLine($"        BigEndian.WriteUInt32(span, {field.Offset}, {field.Name}.RawValue);");
                    break;
                case OtFieldKind.Byte:
                    sb.AppendLine($"        span[{field.Offset}] = {field.Name};");
                    break;
                case OtFieldKind.SByte:
                    sb.AppendLine($"        span[{field.Offset}] = unchecked((byte){field.Name});");
                    break;
                case OtFieldKind.Tag:
                    sb.AppendLine($"        BigEndian.WriteUInt32(span, {field.Offset}, {field.Name}.Value);");
                    break;
                case OtFieldKind.Bytes:
                    if (field.Length > 0)
                        sb.AppendLine($"        {fieldName}.AsSpan().CopyTo(span.Slice({field.Offset}, {field.Length}));");
                    break;
            }
        }

        sb.AppendLine();
        sb.AppendLine(isHead
            ? "        _checksum = OpenTypeChecksum.ComputeHeadDirectoryChecksum(table);"
            : "        _checksum = OpenTypeChecksum.Compute(table);");
        sb.AppendLine("        _built = table;");
        sb.AppendLine("        _dirty = false;");
        sb.AppendLine("        return table;");
        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    private static string GetBuilderFieldName(string propertyName)
    {
        if (string.IsNullOrEmpty(propertyName))
            return "_field";

        if (propertyName.Length == 1)
            return "_" + char.ToLowerInvariant(propertyName[0]);

        return "_" + char.ToLowerInvariant(propertyName[0]) + propertyName.Substring(1);
    }

    private static string GetViewPropertyType(FieldInfo field) => field.Kind switch
    {
        OtFieldKind.UInt16 => "ushort",
        OtFieldKind.Int16 => "short",
        OtFieldKind.UInt24 => "uint",
        OtFieldKind.UInt32 => "uint",
        OtFieldKind.Int32 => "int",
        OtFieldKind.UInt64 => "ulong",
        OtFieldKind.Int64 => "long",
        OtFieldKind.Fixed1616 => "Fixed1616",
        OtFieldKind.Byte => "byte",
        OtFieldKind.SByte => "sbyte",
        OtFieldKind.Tag => "Tag",
        OtFieldKind.Bytes => "ReadOnlySpan<byte>",
        _ => "uint"
    };

    private static string GetBuilderPropertyType(FieldInfo field) => GetViewPropertyType(field);

    private static string GetBuilderFieldType(FieldInfo field) => field.Kind switch
    {
        OtFieldKind.UInt16 => "ushort",
        OtFieldKind.Int16 => "short",
        OtFieldKind.UInt24 => "uint",
        OtFieldKind.UInt32 => "uint",
        OtFieldKind.Int32 => "int",
        OtFieldKind.UInt64 => "ulong",
        OtFieldKind.Int64 => "long",
        OtFieldKind.Fixed1616 => "Fixed1616",
        OtFieldKind.Byte => "byte",
        OtFieldKind.SByte => "sbyte",
        OtFieldKind.Tag => "Tag",
        _ => "uint"
    };

    private static string GetBuilderDefaultValueExpression(FieldInfo field)
    {
        return field.Kind switch
        {
            OtFieldKind.Fixed1616 => $"new Fixed1616(0x{unchecked((uint)field.DefaultValue):X8}u)",
            OtFieldKind.UInt32 => $"0x{unchecked((uint)field.DefaultValue):X8}u",
            OtFieldKind.Int32 => unchecked((int)field.DefaultValue).ToString(),
            OtFieldKind.UInt24 => $"0x{unchecked((uint)field.DefaultValue):X6}u",
            OtFieldKind.UInt16 => unchecked((ushort)field.DefaultValue).ToString(),
            OtFieldKind.Int16 => unchecked((short)field.DefaultValue).ToString(),
            OtFieldKind.UInt64 => $"0x{unchecked((ulong)field.DefaultValue):X16}ul",
            OtFieldKind.Int64 => unchecked((long)field.DefaultValue).ToString(),
            OtFieldKind.Byte => $"0x{unchecked((byte)field.DefaultValue):X2}",
            OtFieldKind.SByte => unchecked((sbyte)field.DefaultValue).ToString(),
            OtFieldKind.Tag => $"new Tag(0x{unchecked((uint)field.DefaultValue):X8}u)",
            _ => "0"
        };
    }

    private static SequentialRecordArrayInfo CreateSequentialRecordArrayInfo(
        Compilation compilation,
        INamedTypeSymbol symbol,
        string name,
        int recordsOffset,
        string? recordsOffsetExpression,
        string? boundsLengthExpression,
        string? recordStrideExpression,
        int recordSize,
        string? countPropertyName,
        string recordTypeName,
        string? outParameterName)
    {
        if (string.IsNullOrWhiteSpace(name))
        {
            return new SequentialRecordArrayInfo(
                Name: name,
                RecordsOffset: recordsOffset,
                RecordsOffsetExpression: recordsOffsetExpression,
                BoundsLengthExpression: boundsLengthExpression,
                RecordStrideExpression: recordStrideExpression,
                RecordSize: recordSize,
                CountPropertyName: countPropertyName,
                RecordTypeName: recordTypeName,
                OutParameterName: outParameterName,
                Fields: ImmutableArray<SequentialRecordFieldInfo>.Empty,
                ErrorMessage: "Name is empty.");
        }

        if (string.IsNullOrWhiteSpace(recordTypeName))
        {
            return new SequentialRecordArrayInfo(
                Name: name,
                RecordsOffset: recordsOffset,
                RecordsOffsetExpression: recordsOffsetExpression,
                BoundsLengthExpression: boundsLengthExpression,
                RecordStrideExpression: recordStrideExpression,
                RecordSize: recordSize,
                CountPropertyName: countPropertyName,
                RecordTypeName: recordTypeName,
                OutParameterName: outParameterName,
                Fields: ImmutableArray<SequentialRecordFieldInfo>.Empty,
                ErrorMessage: "RecordTypeName is empty.");
        }

        if (recordsOffsetExpression is not null && string.IsNullOrWhiteSpace(recordsOffsetExpression))
        {
            return new SequentialRecordArrayInfo(
                Name: name,
                RecordsOffset: recordsOffset,
                RecordsOffsetExpression: recordsOffsetExpression,
                BoundsLengthExpression: boundsLengthExpression,
                RecordStrideExpression: recordStrideExpression,
                RecordSize: recordSize,
                CountPropertyName: countPropertyName,
                RecordTypeName: recordTypeName,
                OutParameterName: outParameterName,
                Fields: ImmutableArray<SequentialRecordFieldInfo>.Empty,
                ErrorMessage: "RecordsOffsetExpression cannot be empty when specified.");
        }

        if (boundsLengthExpression is not null && string.IsNullOrWhiteSpace(boundsLengthExpression))
        {
            return new SequentialRecordArrayInfo(
                Name: name,
                RecordsOffset: recordsOffset,
                RecordsOffsetExpression: recordsOffsetExpression,
                BoundsLengthExpression: boundsLengthExpression,
                RecordStrideExpression: recordStrideExpression,
                RecordSize: recordSize,
                CountPropertyName: countPropertyName,
                RecordTypeName: recordTypeName,
                OutParameterName: outParameterName,
                Fields: ImmutableArray<SequentialRecordFieldInfo>.Empty,
                ErrorMessage: "BoundsLengthExpression cannot be empty when specified.");
        }

        if (recordStrideExpression is not null && string.IsNullOrWhiteSpace(recordStrideExpression))
        {
            return new SequentialRecordArrayInfo(
                Name: name,
                RecordsOffset: recordsOffset,
                RecordsOffsetExpression: recordsOffsetExpression,
                BoundsLengthExpression: boundsLengthExpression,
                RecordStrideExpression: recordStrideExpression,
                RecordSize: recordSize,
                CountPropertyName: countPropertyName,
                RecordTypeName: recordTypeName,
                OutParameterName: outParameterName,
                Fields: ImmutableArray<SequentialRecordFieldInfo>.Empty,
                ErrorMessage: "RecordStrideExpression cannot be empty when specified.");
        }

        if (recordSize <= 0)
        {
            return new SequentialRecordArrayInfo(
                Name: name,
                RecordsOffset: recordsOffset,
                RecordsOffsetExpression: recordsOffsetExpression,
                BoundsLengthExpression: boundsLengthExpression,
                RecordStrideExpression: recordStrideExpression,
                RecordSize: recordSize,
                CountPropertyName: countPropertyName,
                RecordTypeName: recordTypeName,
                OutParameterName: outParameterName,
                Fields: ImmutableArray<SequentialRecordFieldInfo>.Empty,
                ErrorMessage: "RecordSize must be positive.");
        }

        if (!TryResolveSequentialRecordType(compilation, symbol, recordTypeName, out var recordType))
        {
            return new SequentialRecordArrayInfo(
                Name: name,
                RecordsOffset: recordsOffset,
                RecordsOffsetExpression: recordsOffsetExpression,
                BoundsLengthExpression: boundsLengthExpression,
                RecordStrideExpression: recordStrideExpression,
                RecordSize: recordSize,
                CountPropertyName: countPropertyName,
                RecordTypeName: recordTypeName,
                OutParameterName: outParameterName,
                Fields: ImmutableArray<SequentialRecordFieldInfo>.Empty,
                ErrorMessage: $"Record type '{recordTypeName}' was not found in the containing type chain.");
        }

        var ctor = FindSequentialRecordConstructor(recordType);
        if (ctor is null)
        {
            return new SequentialRecordArrayInfo(
                Name: name,
                RecordsOffset: recordsOffset,
                RecordsOffsetExpression: recordsOffsetExpression,
                BoundsLengthExpression: boundsLengthExpression,
                RecordStrideExpression: recordStrideExpression,
                RecordSize: recordSize,
                CountPropertyName: countPropertyName,
                RecordTypeName: recordType.Name,
                OutParameterName: outParameterName,
                Fields: ImmutableArray<SequentialRecordFieldInfo>.Empty,
                ErrorMessage: $"Record type '{recordType.Name}' has no accessible constructor (public/internal with parameters).");
        }

        var fields = ImmutableArray.CreateBuilder<SequentialRecordFieldInfo>(ctor.Parameters.Length);
        int offset = 0;
        for (int i = 0; i < ctor.Parameters.Length; i++)
        {
            var p = ctor.Parameters[i];
            if (!TryGetSequentialRecordFieldRead(p, out var kind, out int size, out string? castTypeName, out string? contextExpression))
            {
                return new SequentialRecordArrayInfo(
                    Name: name,
                    RecordsOffset: recordsOffset,
                    RecordsOffsetExpression: recordsOffsetExpression,
                    BoundsLengthExpression: boundsLengthExpression,
                    RecordStrideExpression: recordStrideExpression,
                    RecordSize: recordSize,
                    CountPropertyName: countPropertyName,
                    RecordTypeName: recordType.Name,
                    OutParameterName: outParameterName,
                    Fields: ImmutableArray<SequentialRecordFieldInfo>.Empty,
                    ErrorMessage: $"Unsupported record field type '{p.Type.ToDisplayString()}' for parameter '{p.Name}'.");
            }

            fields.Add(new SequentialRecordFieldInfo(p.Name, kind, offset, castTypeName, contextExpression));
            offset += size;
        }

        if (offset != recordSize)
        {
            return new SequentialRecordArrayInfo(
                Name: name,
                RecordsOffset: recordsOffset,
                RecordsOffsetExpression: recordsOffsetExpression,
                BoundsLengthExpression: boundsLengthExpression,
                RecordStrideExpression: recordStrideExpression,
                RecordSize: recordSize,
                CountPropertyName: countPropertyName,
                RecordTypeName: recordType.Name,
                OutParameterName: outParameterName,
                Fields: fields.ToImmutable(),
                ErrorMessage: $"RecordSize mismatch: constructor layout is {offset} bytes but attribute specifies {recordSize} bytes.");
        }

        return new SequentialRecordArrayInfo(
            Name: name,
            RecordsOffset: recordsOffset,
            RecordsOffsetExpression: recordsOffsetExpression,
            BoundsLengthExpression: boundsLengthExpression,
            RecordStrideExpression: recordStrideExpression,
            RecordSize: recordSize,
            CountPropertyName: countPropertyName,
            RecordTypeName: recordType.Name,
            OutParameterName: outParameterName,
            Fields: fields.ToImmutable(),
            ErrorMessage: null);
    }

    private static bool TryResolveSequentialRecordType(Compilation compilation, INamedTypeSymbol symbol, string recordTypeName, out INamedTypeSymbol typeSymbol)
    {
        for (INamedTypeSymbol? cur = symbol; cur is not null; cur = cur.ContainingType)
        {
            var matches = cur.GetTypeMembers(recordTypeName);
            if (matches.Length != 0)
            {
                typeSymbol = matches[0];
                return true;
            }
        }

        if (compilation.GetTypeByMetadataName(recordTypeName) is INamedTypeSymbol fullMatch)
        {
            typeSymbol = fullMatch;
            return true;
        }

        string ns = symbol.ContainingNamespace.ToDisplayString();
        if (!string.IsNullOrWhiteSpace(ns) &&
            compilation.GetTypeByMetadataName(ns + "." + recordTypeName) is INamedTypeSymbol nsMatch)
        {
            typeSymbol = nsMatch;
            return true;
        }

        typeSymbol = null!;
        return false;
    }

    private static IMethodSymbol? FindSequentialRecordConstructor(INamedTypeSymbol recordType)
    {
        IMethodSymbol? best = null;
        foreach (var ctor in recordType.InstanceConstructors)
        {
            if (ctor.Parameters.Length == 0)
                continue;

            if (ctor.DeclaredAccessibility is not Accessibility.Public and not Accessibility.Internal)
                continue;

            if (best is null ||
                ctor.Parameters.Length > best.Parameters.Length ||
                (ctor.Parameters.Length == best.Parameters.Length && ctor.DeclaredAccessibility == Accessibility.Public && best.DeclaredAccessibility != Accessibility.Public))
            {
                best = ctor;
            }
        }

        return best;
    }

    private static bool TryGetSequentialRecordFieldRead(IParameterSymbol parameter, out SequentialRecordFieldKind kind, out int size, out string? castTypeName, out string? contextExpression)
    {
        contextExpression = null;
        castTypeName = null;

        ITypeSymbol type = parameter.Type;

        if (TryGetSequentialRecordContextExpression(parameter, out string ctx))
        {
            if (string.IsNullOrWhiteSpace(ctx))
            {
                kind = default;
                size = 0;
                return false;
            }

            kind = SequentialRecordFieldKind.Context;
            size = 0;
            contextExpression = ctx;
            return true;
        }

        if (type.TypeKind == TypeKind.Enum && type is INamedTypeSymbol enumType && enumType.EnumUnderlyingType is not null)
        {
            castTypeName = enumType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            type = enumType.EnumUnderlyingType;
        }

        if (TryGetSequentialRecordFieldOverride(parameter, out var overrideKind))
        {
            if (overrideKind == OtFieldKind.UInt24 && type.SpecialType == SpecialType.System_UInt32)
            {
                kind = SequentialRecordFieldKind.UInt24;
                size = 3;
                return true;
            }

            kind = default;
            size = 0;
            return false;
        }

        switch (type.SpecialType)
        {
            case SpecialType.System_Byte:
                kind = SequentialRecordFieldKind.Byte;
                size = 1;
                return true;

            case SpecialType.System_SByte:
                kind = SequentialRecordFieldKind.SByte;
                size = 1;
                return true;

            case SpecialType.System_UInt16:
                kind = SequentialRecordFieldKind.UInt16;
                size = 2;
                return true;

            case SpecialType.System_Int16:
                kind = SequentialRecordFieldKind.Int16;
                size = 2;
                return true;

            case SpecialType.System_UInt32:
                kind = SequentialRecordFieldKind.UInt32;
                size = 4;
                return true;

            case SpecialType.System_Int32:
                kind = SequentialRecordFieldKind.Int32;
                size = 4;
                return true;
        }

        if (type is INamedTypeSymbol named &&
            named.Name == "Tag" &&
            named.ContainingNamespace.ToDisplayString() == "OTFontFile2")
        {
            kind = SequentialRecordFieldKind.Tag;
            size = 4;
            return true;
        }

        if (type is INamedTypeSymbol fixed1616 &&
            fixed1616.Name == "Fixed1616" &&
            fixed1616.ContainingNamespace.ToDisplayString() == "OTFontFile2")
        {
            kind = SequentialRecordFieldKind.Fixed1616;
            size = 4;
            return true;
        }

        if (type is INamedTypeSymbol f2dot14 &&
            f2dot14.Name == "F2Dot14" &&
            f2dot14.ContainingNamespace.ToDisplayString() == "OTFontFile2")
        {
            kind = SequentialRecordFieldKind.F2Dot14;
            size = 2;
            return true;
        }

        if (type is INamedTypeSymbol varIdx &&
            varIdx.Name == "VarIdx" &&
            varIdx.ContainingNamespace.ToDisplayString() == "OTFontFile2.Tables")
        {
            kind = SequentialRecordFieldKind.VarIdx;
            size = 4;
            return true;
        }

        kind = default;
        size = 0;
        return false;
    }

    private static bool TryGetSequentialRecordFieldOverride(IParameterSymbol parameter, out OtFieldKind kind)
    {
        foreach (var a in parameter.GetAttributes())
        {
            if (a.AttributeClass?.Name != "OtRecordFieldAttribute")
                continue;

            if (a.AttributeClass.ContainingNamespace.ToDisplayString() != "OTFontFile2.SourceGen")
                continue;

            if (a.ConstructorArguments.Length != 1)
                continue;

            object? value = a.ConstructorArguments[0].Value;
            if (value is null)
                continue;

            kind = (OtFieldKind)Convert.ToInt32(value);
            return true;
        }

        kind = default;
        return false;
    }

    private static bool TryGetSequentialRecordContextExpression(IParameterSymbol parameter, out string expression)
    {
        foreach (var a in parameter.GetAttributes())
        {
            if (a.AttributeClass?.Name != "OtRecordContextAttribute")
                continue;

            if (a.AttributeClass.ContainingNamespace.ToDisplayString() != "OTFontFile2.SourceGen")
                continue;

            if (a.ConstructorArguments.Length != 1)
                continue;

            if (a.ConstructorArguments[0].Value is not string s)
                continue;

            expression = s;
            return true;
        }

        expression = string.Empty;
        return false;
    }

    private static string EscapeIdentifier(string name)
    {
        if (string.IsNullOrEmpty(name))
            return name;

        if (SyntaxFacts.GetKeywordKind(name) != SyntaxKind.None || SyntaxFacts.GetContextualKeywordKind(name) != SyntaxKind.None)
            return "@" + name;

        return name;
    }

    private static string GetSequentialRecordReadExpression(SequentialRecordFieldKind kind, string offsetExpr, string? castTypeName)
    {
        string expr = kind switch
        {
            SequentialRecordFieldKind.Byte => $"data[{offsetExpr}]",
            SequentialRecordFieldKind.SByte => $"unchecked((sbyte)data[{offsetExpr}])",
            SequentialRecordFieldKind.UInt16 => $"BigEndian.ReadUInt16(data, {offsetExpr})",
            SequentialRecordFieldKind.Int16 => $"BigEndian.ReadInt16(data, {offsetExpr})",
            SequentialRecordFieldKind.UInt24 => $"BigEndian.ReadUInt24(data, {offsetExpr})",
            SequentialRecordFieldKind.UInt32 => $"BigEndian.ReadUInt32(data, {offsetExpr})",
            SequentialRecordFieldKind.Int32 => $"BigEndian.ReadInt32(data, {offsetExpr})",
            SequentialRecordFieldKind.Tag => $"new Tag(BigEndian.ReadUInt32(data, {offsetExpr}))",
            SequentialRecordFieldKind.Fixed1616 => $"new Fixed1616(BigEndian.ReadUInt32(data, {offsetExpr}))",
            SequentialRecordFieldKind.F2Dot14 => $"new F2Dot14(BigEndian.ReadInt16(data, {offsetExpr}))",
            SequentialRecordFieldKind.VarIdx => $"new VarIdx(BigEndian.ReadUInt16(data, {offsetExpr}), BigEndian.ReadUInt16(data, {offsetExpr} + 2))",
            _ => "default"
        };

        return castTypeName is null ? expr : $"({castTypeName}){expr}";
    }

    private static string GetViewReadExpression(FieldInfo field, string? baseOffsetExpr)
    {
        string offsetExpr = baseOffsetExpr is null ? field.Offset.ToString() : $"{baseOffsetExpr} + {field.Offset}";

        return field.Kind switch
        {
            OtFieldKind.UInt16 => $"BigEndian.ReadUInt16(_table.Span, {offsetExpr})",
            OtFieldKind.Int16 => $"BigEndian.ReadInt16(_table.Span, {offsetExpr})",
            OtFieldKind.UInt24 => $"BigEndian.ReadUInt24(_table.Span, {offsetExpr})",
            OtFieldKind.UInt32 => $"BigEndian.ReadUInt32(_table.Span, {offsetExpr})",
            OtFieldKind.Int32 => $"BigEndian.ReadInt32(_table.Span, {offsetExpr})",
            OtFieldKind.UInt64 => $"BigEndian.ReadUInt64(_table.Span, {offsetExpr})",
            OtFieldKind.Int64 => $"BigEndian.ReadInt64(_table.Span, {offsetExpr})",
            OtFieldKind.Fixed1616 => $"new Fixed1616(BigEndian.ReadUInt32(_table.Span, {offsetExpr}))",
            OtFieldKind.Byte => $"_table.Span[{offsetExpr}]",
            OtFieldKind.SByte => $"unchecked((sbyte)_table.Span[{offsetExpr}])",
            OtFieldKind.Tag => $"new Tag(BigEndian.ReadUInt32(_table.Span, {offsetExpr}))",
            OtFieldKind.Bytes => $"_table.Span.Slice({offsetExpr}, {field.Length})",
            _ => "0"
        };
    }

    private static uint TagToUInt32(string tag)
    {
        if (tag.Length != 4)
            return 0;

        return (uint)tag[0] << 24 |
               (uint)tag[1] << 16 |
               (uint)tag[2] << 8 |
               tag[3];
    }

    private static string GetHintBaseName(INamedTypeSymbol symbol)
    {
        string s = symbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
        if (s.StartsWith("global::", StringComparison.Ordinal))
            s = s.Substring("global::".Length);

        var sb = new StringBuilder(s.Length);
        foreach (char c in s)
        {
            sb.Append(char.IsLetterOrDigit(c) ? c : '_');
        }

        return sb.ToString();
    }

    private static ImmutableArray<TypeInfo> GetContainingTypes(INamedTypeSymbol symbol)
    {
        var list = new List<TypeInfo>();
        for (INamedTypeSymbol? cur = symbol.ContainingType; cur is not null; cur = cur.ContainingType)
        {
            list.Add(new TypeInfo(
                Name: cur.Name,
                TypeKind: cur.TypeKind,
                Accessibility: cur.DeclaredAccessibility,
                IsReadOnly: cur.IsReadOnly,
                IsRefLike: cur.IsRefLikeType,
                IsStatic: cur.IsStatic,
                IsRecord: cur.IsRecord,
                IsPartial: IsPartial(cur),
                Arity: cur.TypeParameters.Length));
        }

        list.Reverse();
        return list.ToImmutableArray();
    }

    private static bool IsPartial(INamedTypeSymbol symbol)
    {
        foreach (var syntaxRef in symbol.DeclaringSyntaxReferences)
        {
            if (syntaxRef.GetSyntax() is TypeDeclarationSyntax t && t.Modifiers.Any(SyntaxKind.PartialKeyword))
                return true;
        }

        return false;
    }

    private sealed record TableInfo(
        TableKind Kind,
        string HintName,
        string Namespace,
        TypeInfo Type,
        ImmutableArray<TypeInfo> ContainingTypes,
        string Tag,
        int MinLength,
        bool GenerateTryCreate,
        bool GenerateStorage,
        bool GenerateBuilder,
        string? BuilderName,
        DiscriminatedUnionInfo? DiscriminatedUnion,
        ImmutableArray<FieldInfo> Fields,
        ImmutableArray<TagOffsetRecordArrayInfo> TagOffsetRecordArrays,
        ImmutableArray<UInt16ArrayInfo> UInt16Arrays,
        ImmutableArray<UInt32ArrayInfo> UInt32Arrays,
        ImmutableArray<SequentialRecordArrayInfo> SequentialRecordArrays,
        ImmutableArray<SubTableOffsetInfo> SubTableOffsets,
        ImmutableArray<SubTableOffsetArrayInfo> SubTableOffsetArrays);

    private sealed record DiscriminatedUnionInfo(
        string? DiscriminantFieldName,
        ImmutableArray<DiscriminatedCaseInfo> Cases,
        string? ErrorMessage);

    private sealed record DiscriminatedCaseInfo(
        int Value,
        string VariantTypeName,
        CaseVariantKind VariantKind,
        string Name,
        string? OutParameterName,
        string? ErrorMessage);

    private enum CaseVariantKind
    {
        Unknown,
        Table,
        SubTable
    }

    private sealed record TagOffsetRecordArrayInfo(
        string Name,
        int RecordsOffset,
        string? CountPropertyName,
        bool Offset32,
        string? SubTableTypeName,
        string? OutParameterName,
        string? ErrorMessage);

    private sealed record UInt16ArrayInfo(
        string Name,
        int ValuesOffset,
        string? ValuesOffsetExpression,
        string? BoundsLengthExpression,
        string? CountPropertyName,
        string? OutParameterName,
        int CountAdjustment);

    private sealed record UInt32ArrayInfo(
        string Name,
        int ValuesOffset,
        string? ValuesOffsetExpression,
        string? BoundsLengthExpression,
        string? CountPropertyName,
        string? OutParameterName,
        int CountAdjustment);

    private sealed record SubTableOffsetInfo(
        string Name,
        string OffsetPropertyName,
        string SubTableTypeName,
        string? OutParameterName,
        bool RelativeToTableStart,
        string? ErrorMessage);

    private sealed record SubTableOffsetArrayInfo(
        string Name,
        string OffsetArrayName,
        string SubTableTypeName,
        string? OutParameterName,
        bool RelativeToTableStart,
        string? ErrorMessage);

    private enum SequentialRecordFieldKind
    {
        Context,
        Byte,
        SByte,
        UInt16,
        Int16,
        UInt24,
        UInt32,
        Int32,
        Tag,
        Fixed1616,
        F2Dot14,
        VarIdx
    }

    private sealed record SequentialRecordFieldInfo(
        string ParameterName,
        SequentialRecordFieldKind Kind,
        int Offset,
        string? CastTypeName,
        string? ContextExpression);

    private sealed record SequentialRecordArrayInfo(
        string Name,
        int RecordsOffset,
        string? RecordsOffsetExpression,
        string? BoundsLengthExpression,
        string? RecordStrideExpression,
        int RecordSize,
        string? CountPropertyName,
        string RecordTypeName,
        string? OutParameterName,
        ImmutableArray<SequentialRecordFieldInfo> Fields,
        string? ErrorMessage);

    private sealed record TagEntry(
        string Tag,
        string Name,
        uint Value);

    private sealed record TypeInfo(
        string Name,
        TypeKind TypeKind,
        Accessibility Accessibility,
        bool IsReadOnly,
        bool IsRefLike,
        bool IsStatic,
        bool IsRecord,
        bool IsPartial,
        int Arity);

    private sealed record FieldInfo(
        string Name,
        OtFieldKind Kind,
        int Offset,
        int Length,
        bool InView,
        bool InBuilder,
        bool HasDefaultValue,
        long DefaultValue,
        byte PadByte);

    private enum OtFieldKind
    {
        UInt16,
        Int16,
        UInt32,
        Int32,
        UInt64,
        Int64,
        Fixed1616,
        Byte,
        SByte,
        Tag,
        Bytes,
        UInt24
    }

    private enum TableKind
    {
        Table,
        SubTable
    }

    private static bool IsSupportedDiscriminantKind(OtFieldKind kind) => kind is OtFieldKind.Byte
        or OtFieldKind.SByte
        or OtFieldKind.UInt16
        or OtFieldKind.Int16
        or OtFieldKind.UInt24
        or OtFieldKind.UInt32
        or OtFieldKind.Int32
        or OtFieldKind.UInt64
        or OtFieldKind.Int64;

    private static bool IsDiscriminantValueInRange(OtFieldKind kind, int value) => kind switch
    {
        OtFieldKind.Byte => (uint)value <= byte.MaxValue,
        OtFieldKind.SByte => value is >= sbyte.MinValue and <= sbyte.MaxValue,
        OtFieldKind.UInt16 => (uint)value <= ushort.MaxValue,
        OtFieldKind.Int16 => value is >= short.MinValue and <= short.MaxValue,
        OtFieldKind.UInt24 => (uint)value <= 0xFFFFFFu,
        OtFieldKind.UInt32 => value >= 0,
        OtFieldKind.Int32 => true,
        OtFieldKind.UInt64 => value >= 0,
        OtFieldKind.Int64 => true,
        _ => false
    };

    private static bool TryGetDiscriminantLiteral(OtFieldKind kind, int value, out string literal)
    {
        literal = kind switch
        {
            OtFieldKind.Byte => $"(byte){value}",
            OtFieldKind.SByte => $"(sbyte){value}",
            OtFieldKind.UInt16 => $"(ushort){value}",
            OtFieldKind.Int16 => $"(short){value}",
            OtFieldKind.UInt24 => $"(uint){value}",
            OtFieldKind.UInt32 => $"(uint){value}",
            OtFieldKind.Int32 => value.ToString(),
            OtFieldKind.UInt64 => $"(ulong){value}",
            OtFieldKind.Int64 => $"(long){value}",
            _ => string.Empty
        };

        return literal.Length != 0;
    }
}
