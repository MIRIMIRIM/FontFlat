using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace OTFontFile2.Generators;

[Generator]
public sealed class OtFontFile2CodecRegistryGenerator : IIncrementalGenerator
{
    private const string OtTableAttributeMetadataName = "OTFontFile2.SourceGen.OtTableAttribute";
    private const string OtTableBuilderAttributeMetadataName = "OTFontFile2.SourceGen.OtTableBuilderAttribute";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var fromTables = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                OtTableAttributeMetadataName,
                predicate: static (node, _) => node is StructDeclarationSyntax,
                transform: static (ctx, _) => GetCodecFromGeneratedTableBuilder(ctx))
            .Where(static c => c is not null)
            .Select(static (c, _) => c!);

        var fromBuilders = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                OtTableBuilderAttributeMetadataName,
                predicate: static (node, _) => node is ClassDeclarationSyntax,
                transform: static (ctx, _) => GetCodecFromBuilder(ctx))
            .Where(static c => c is not null)
            .Select(static (c, _) => c!);

        var combined = fromTables.Collect().Combine(fromBuilders.Collect());
        context.RegisterSourceOutput(
            combined,
            static (spc, pair) =>
            {
                var tableCodecs = pair.Left;
                var builderCodecs = pair.Right;

                int capacity = (tableCodecs.IsDefault ? 0 : tableCodecs.Length) + (builderCodecs.IsDefault ? 0 : builderCodecs.Length);
                var merged = ImmutableArray.CreateBuilder<CodecInfo>(capacity);

                if (!tableCodecs.IsDefaultOrEmpty)
                    merged.AddRange(tableCodecs);
                if (!builderCodecs.IsDefaultOrEmpty)
                    merged.AddRange(builderCodecs);

                Execute(spc, merged.ToImmutable());
            });
    }

    private static void Execute(SourceProductionContext context, ImmutableArray<CodecInfo> codecs)
    {
        if (codecs.IsDefaultOrEmpty)
            return;

        var unique = new Dictionary<(string tag, string builderType), CodecInfo>();
        for (int i = 0; i < codecs.Length; i++)
        {
            var c = codecs[i];
            if (string.IsNullOrWhiteSpace(c.Tag) || c.Tag.Length != 4)
                continue;
            if (string.IsNullOrWhiteSpace(c.BuilderType))
                continue;

            unique[(c.Tag, c.BuilderType)] = c;
        }

        var ordered = unique.Values
            .OrderBy(static c => c.Tag, StringComparer.Ordinal)
            .ThenBy(static c => c.BuilderType, StringComparer.Ordinal)
            .ToArray();

        context.AddSource(
            "OTFontFile2.TableBuilderCodecRegistry.Generated.g.cs",
            SourceText.From(Generate(ordered), Encoding.UTF8));
    }

    private static string Generate(CodecInfo[] codecs)
    {
        static string EscapeIdentifier(string value)
        {
            if (string.IsNullOrEmpty(value))
                return "_";

            var sb = new StringBuilder(value.Length);
            for (int i = 0; i < value.Length; i++)
            {
                char c = value[i];
                sb.Append(char.IsLetterOrDigit(c) ? c : '_');
            }
            return sb.ToString();
        }

        static void AppendLine(StringBuilder sb, int indentLevel, string line)
        {
            for (int i = 0; i < indentLevel; i++)
                sb.Append("    ");
            sb.AppendLine(line);
        }

        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using OTFontFile2.Tables;");
        sb.AppendLine();
        sb.AppendLine("namespace OTFontFile2;");
        sb.AppendLine();
        sb.AppendLine("public sealed partial class TableBuilderCodecRegistry");
        sb.AppendLine("{");

        AppendLine(sb, 1, "private static void RegisterGenerated(TableBuilderCodecRegistry r)");
        AppendLine(sb, 1, "{");
        AppendLine(sb, 2, "if (r is null) throw new ArgumentNullException(nameof(r));");
        sb.AppendLine();

        for (int i = 0; i < codecs.Length; i++)
        {
            string className = "Generated_" + EscapeIdentifier(codecs[i].BuilderType) + "_Codec";
            AppendLine(sb, 2, $"r.Register(new {className}());");
        }

        AppendLine(sb, 1, "}");
        sb.AppendLine();

        for (int i = 0; i < codecs.Length; i++)
        {
            CodecInfo c = codecs[i];
            string className = "Generated_" + EscapeIdentifier(c.BuilderType) + "_Codec";
            uint tagValue = TagToUInt32(c.Tag);

            AppendLine(sb, 1, $"private sealed class {className} : TableBuilderCodec<{c.BuilderType}>");
            AppendLine(sb, 1, "{");
            AppendLine(sb, 2, $"public override Tag Tag => new(0x{tagValue:X8}u);");
            sb.AppendLine();

            AppendLine(sb, 2, $"public override bool TryCreateBuilder(FontModel model, out {c.BuilderType} builder)");
            AppendLine(sb, 2, "{");

            if (c.Construction.RequiresContext)
            {
                AppendLine(sb, 3, "builder = null!;");
                sb.AppendLine();

                for (int reqIndex = 0; reqIndex < c.Construction.ContextValues.Length; reqIndex++)
                {
                    var req = c.Construction.ContextValues[reqIndex];
                    AppendLine(sb, 3, $"if (!{GetContextGetterExpression(req.Kind, req.LocalName)})");
                    AppendLine(sb, 4, "return false;");
                    sb.AppendLine();
                }
            }

            if (c.TryFromPlans.Length != 0)
            {
                AppendLine(sb, 3, "if (model.HasBaseFont)");
                AppendLine(sb, 3, "{");

                for (int planIndex = 0; planIndex < c.TryFromPlans.Length; planIndex++)
                {
                    var plan = c.TryFromPlans[planIndex];
                    AppendLine(sb, 4, "{");

                    if (plan.Kind == TryFromPlanKind.Font)
                    {
                        AppendLine(sb, 5, $"if ({c.BuilderType}.TryFrom(model.BaseFont, out var from))");
                        AppendLine(sb, 5, "{");
                        AppendLine(sb, 6, "builder = from;");
                        AppendLine(sb, 6, "return true;");
                        AppendLine(sb, 5, "}");
                    }
                    else
                    {
                        AppendLine(sb, 5, "if (");
                        AppendLine(sb, 6, $"model.BaseFont.TryGetTableSlice(new Tag(0x{tagValue:X8}u), out var slice0)");
                        AppendLine(sb, 6, $"&& {plan.TableTypes[0]}.TryCreate(slice0, out var table0)");

                        int tableVarIndex = 1;
                        for (int p = 0; p < plan.Parameters.Length; p++)
                        {
                            var param = plan.Parameters[p];
                            if (param.Kind == TryFromParameterKind.Table && tableVarIndex != 0)
                            {
                                uint extraTagValue = TagToUInt32(param.Tag!);
                                AppendLine(sb, 6, $"&& model.BaseFont.TryGetTableSlice(new Tag(0x{extraTagValue:X8}u), out var slice{tableVarIndex})");
                                AppendLine(sb, 6, $"&& {param.TypeName}.TryCreate(slice{tableVarIndex}, out var table{tableVarIndex})");
                                tableVarIndex++;
                            }
                            else if (param.Kind == TryFromParameterKind.Context && !c.Construction.ContainsContextKind(param.ContextKind))
                            {
                                AppendLine(sb, 6, $"&& {GetContextGetterExpression(param.ContextKind, param.Name)}");
                            }
                        }

                        AppendLine(sb, 6, $"&& {c.BuilderType}.TryFrom({GenerateTryFromArgumentList(c, plan, requiredContextOnly: false)}, out var from))");
                        AppendLine(sb, 5, "{");
                        AppendLine(sb, 6, "builder = from;");
                        AppendLine(sb, 6, "return true;");
                        AppendLine(sb, 5, "}");
                    }

                    AppendLine(sb, 4, "}");
                    sb.AppendLine();
                }

                AppendLine(sb, 3, "}");
                sb.AppendLine();
            }

            AppendLine(sb, 3, $"builder = {c.Construction.NewExpression};");
            AppendLine(sb, 3, "return true;");

            AppendLine(sb, 2, "}");
            AppendLine(sb, 1, "}");
            sb.AppendLine();
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GetContextGetterExpression(ContextValueKind kind, string localName)
    {
        return kind switch
        {
            ContextValueKind.MaxpNumGlyphs => $"model.TryGetMaxpNumGlyphs(out ushort {localName})",
            ContextValueKind.HheaNumberOfHMetrics => $"model.TryGetHheaNumberOfHMetrics(out ushort {localName})",
            ContextValueKind.VheaNumOfLongVerMetrics => $"model.TryGetVheaNumOfLongVerMetrics(out ushort {localName})",
            _ => throw new NotSupportedException($"Unsupported context kind: {kind}")
        };
    }

    private static string GenerateTryFromArgumentList(CodecInfo codec, TryFromPlan plan, bool requiredContextOnly)
    {
        // First parameter is always table0 for table plans.
        if (plan.Kind != TryFromPlanKind.Table)
            return string.Empty;

        var args = new List<string>();
        args.Add("table0");

        int tableIndex = 1;
        for (int i = 0; i < plan.Parameters.Length; i++)
        {
            var p = plan.Parameters[i];
            if (p.Kind == TryFromParameterKind.Table)
            {
                args.Add($"table{tableIndex}");
                tableIndex++;
            }
            else
            {
                if (requiredContextOnly && !codec.Construction.ContainsContextKind(p.ContextKind))
                    continue;

                args.Add(p.Name);
            }
        }

        return string.Join(", ", args);
    }

    private static CodecInfo? GetCodecFromGeneratedTableBuilder(GeneratorAttributeSyntaxContext ctx)
    {
        if (ctx.TargetSymbol is not INamedTypeSymbol tableType || tableType.TypeKind != TypeKind.Struct)
            return null;

        if (tableType.IsGenericType || tableType.IsImplicitlyDeclared)
            return null;

        var attribute = ctx.Attributes[0];
        if (attribute.ConstructorArguments.Length < 1 || attribute.ConstructorArguments[0].Value is not string tag)
            return null;

        bool generateBuilder = false;
        string? builderName = null;
        foreach (var kv in attribute.NamedArguments)
        {
            if (kv.Key == "GenerateBuilder" && kv.Value.Value is bool gb)
                generateBuilder = gb;
            else if (kv.Key == "BuilderName" && kv.Value.Value is string s && !string.IsNullOrWhiteSpace(s))
                builderName = s;
        }

        if (!generateBuilder)
            return null;

        string name = string.IsNullOrWhiteSpace(builderName) ? tableType.Name + "Builder" : builderName!;

        string builderType = "global::" + tableType.ContainingNamespace.ToDisplayString() + "." + name;
        string tableTypeName = tableType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);

        var construction = new ConstructionPlan(
            NewExpression: $"new {builderType}()",
            ContextValues: ImmutableArray<ContextValue>.Empty);

        var plan = new TryFromPlan(
            Kind: TryFromPlanKind.Table,
            TableTypes: ImmutableArray.Create(tableTypeName),
            Parameters: ImmutableArray<TryFromParameter>.Empty);

        return new CodecInfo(
            Tag: tag,
            BuilderType: builderType,
            Construction: construction,
            TryFromPlans: ImmutableArray.Create(plan));
    }

    private static CodecInfo? GetCodecFromBuilder(GeneratorAttributeSyntaxContext ctx)
    {
        if (ctx.TargetSymbol is not INamedTypeSymbol builderType || builderType.TypeKind != TypeKind.Class)
            return null;

        if (builderType.IsGenericType || builderType.IsImplicitlyDeclared)
            return null;

        var attribute = ctx.Attributes[0];
        if (attribute.ConstructorArguments.Length < 1 || attribute.ConstructorArguments[0].Value is not string tag)
            return null;

        if (!TryGetConstructionPlan(builderType, out var construction))
            return null;

        if (!TryGetTryFromPlans(builderType, tag, out var plans))
            return null;

        return new CodecInfo(
            Tag: tag,
            BuilderType: builderType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            Construction: construction,
            TryFromPlans: plans);
    }

    private static bool TryGetConstructionPlan(INamedTypeSymbol builderType, out ConstructionPlan plan)
    {
        plan = default!;

        // Prefer: implicit/public parameterless, or all-optional.
        foreach (var ctor in builderType.InstanceConstructors)
        {
            if (ctor.DeclaredAccessibility == Accessibility.Private)
                continue;

            if (ctor.IsImplicitlyDeclared || ctor.Parameters.Length == 0)
            {
                plan = new ConstructionPlan(
                    NewExpression: $"new {builderType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}()",
                    ContextValues: ImmutableArray<ContextValue>.Empty);
                return true;
            }

            bool allOptional = true;
            foreach (var p in ctor.Parameters)
            {
                if (!p.IsOptional && !p.HasExplicitDefaultValue)
                {
                    allOptional = false;
                    break;
                }
            }

            if (allOptional)
            {
                plan = new ConstructionPlan(
                    NewExpression: $"new {builderType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}()",
                    ContextValues: ImmutableArray<ContextValue>.Empty);
                return true;
            }
        }

        // Next: ctor that can be satisfied from model context.
        foreach (var ctor in builderType.InstanceConstructors)
        {
            if (ctor.DeclaredAccessibility == Accessibility.Private)
                continue;

            if (ctor.Parameters.Length == 0)
                continue;

            var contextValues = ImmutableArray.CreateBuilder<ContextValue>(ctor.Parameters.Length);
            var argNames = new List<string>(ctor.Parameters.Length);

            bool ok = true;
            for (int i = 0; i < ctor.Parameters.Length; i++)
            {
                var p = ctor.Parameters[i];
                if (!TryMapContextParameter(p, out var kind))
                {
                    ok = false;
                    break;
                }

                string localName = p.Name;
                contextValues.Add(new ContextValue(kind, localName));
                argNames.Add(localName);
            }

            if (!ok)
                continue;

            plan = new ConstructionPlan(
                NewExpression: $"new {builderType.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat)}({string.Join(", ", argNames)})",
                ContextValues: contextValues.ToImmutable());
            return true;
        }

        return false;
    }

    private static bool TryGetTryFromPlans(INamedTypeSymbol builderType, string builderTag, out ImmutableArray<TryFromPlan> plans)
    {
        plans = default;

        // Prefer: TryFrom(SfntFont font, out Builder builder)
        if (HasTryFromFont(builderType))
        {
            plans = ImmutableArray.Create(new TryFromPlan(
                Kind: TryFromPlanKind.Font,
                TableTypes: ImmutableArray<string>.Empty,
                Parameters: ImmutableArray<TryFromParameter>.Empty));
            return true;
        }

        var list = new List<TryFromPlan>();

        foreach (var member in builderType.GetMembers("TryFrom"))
        {
            if (member is not IMethodSymbol m)
                continue;
            if (!m.IsStatic || m.MethodKind != MethodKind.Ordinary)
                continue;
            if (m.Arity != 0)
                continue;
            if (m.ReturnType.SpecialType != SpecialType.System_Boolean)
                continue;
            if (m.Parameters.Length < 2)
                continue;

            int last = m.Parameters.Length - 1;
            if (m.Parameters[last].RefKind != RefKind.Out || !SymbolEqualityComparer.Default.Equals(m.Parameters[last].Type, builderType))
                continue;

            if (m.Parameters[0].Type is not INamedTypeSymbol table0Type)
                continue;

            // Table-based: first param must look like a table wrapper.
            if (!IsTableWrapperType(table0Type))
                continue;

            var tableTypes = new List<string>();
            tableTypes.Add(table0Type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));

            var parameters = new List<TryFromParameter>();
            bool ok = true;

            for (int i = 1; i < last; i++)
            {
                var p = m.Parameters[i];

                if (p.Type is INamedTypeSymbol t && IsTableWrapperType(t))
                {
                    if (!TryGetOtTableTag(t, out string? tag) || tag is null || tag.Length != 4)
                    {
                        ok = false;
                        break;
                    }

                    parameters.Add(TryFromParameter.Table(typeName: t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat), tag: tag));
                    tableTypes.Add(t.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat));
                    continue;
                }

                if (TryMapContextParameter(p, out var kind))
                {
                    parameters.Add(TryFromParameter.Context(kind, name: p.Name));
                    continue;
                }

                ok = false;
                break;
            }

            if (!ok)
                continue;

            list.Add(new TryFromPlan(
                Kind: TryFromPlanKind.Table,
                TableTypes: tableTypes.ToImmutableArray(),
                Parameters: parameters.ToImmutableArray()));
        }

        if (list.Count == 0)
            return false;

        list.Sort(static (a, b) =>
        {
            int inputCountA = 1 + a.Parameters.Length;
            int inputCountB = 1 + b.Parameters.Length;
            int cmp = inputCountB.CompareTo(inputCountA);
            if (cmp != 0)
                return cmp;

            int tableCountA = a.TableTypes.Length;
            int tableCountB = b.TableTypes.Length;
            cmp = tableCountB.CompareTo(tableCountA);
            if (cmp != 0)
                return cmp;

            return 0;
        });

        plans = list.ToImmutableArray();
        return true;
    }

    private static bool HasTryFromFont(INamedTypeSymbol builderType)
    {
        foreach (var member in builderType.GetMembers("TryFrom"))
        {
            if (member is not IMethodSymbol m)
                continue;
            if (!m.IsStatic || m.MethodKind != MethodKind.Ordinary)
                continue;
            if (m.Arity != 0)
                continue;
            if (m.ReturnType.SpecialType != SpecialType.System_Boolean)
                continue;
            if (m.Parameters.Length != 2)
                continue;

            if (m.Parameters[0].Type is not INamedTypeSymbol fontType ||
                fontType.Name != "SfntFont" ||
                fontType.ContainingNamespace.ToDisplayString() != "OTFontFile2")
            {
                continue;
            }

            if (m.Parameters[1].RefKind != RefKind.Out)
                continue;
            if (!SymbolEqualityComparer.Default.Equals(m.Parameters[1].Type, builderType))
                continue;

            return true;
        }

        return false;
    }

    private static bool IsTableWrapperType(INamedTypeSymbol type)
    {
        if (type.TypeKind != TypeKind.Struct)
            return false;

        if (!type.Name.EndsWith("Table", StringComparison.Ordinal))
            return false;

        string ns = type.ContainingNamespace.ToDisplayString();
        return ns.StartsWith("OTFontFile2.Tables", StringComparison.Ordinal);
    }

    private static bool TryGetOtTableTag(INamedTypeSymbol tableType, out string? tag)
    {
        tag = null;

        foreach (var a in tableType.GetAttributes())
        {
            if (a.AttributeClass is null)
                continue;

            string attrName = a.AttributeClass.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat);
            if (attrName.StartsWith("global::", StringComparison.Ordinal))
                attrName = attrName.Substring("global::".Length);

            if (attrName != OtTableAttributeMetadataName)
                continue;

            if (a.ConstructorArguments.Length >= 1 && a.ConstructorArguments[0].Value is string s && !string.IsNullOrWhiteSpace(s))
            {
                tag = s;
                return true;
            }
        }

        return false;
    }

    private static bool TryMapContextParameter(IParameterSymbol parameter, out ContextValueKind kind)
    {
        kind = default;

        if (parameter.Type.SpecialType != SpecialType.System_UInt16)
            return false;

        return parameter.Name switch
        {
            "numGlyphs" => (kind = ContextValueKind.MaxpNumGlyphs) == ContextValueKind.MaxpNumGlyphs,
            "glyphCount" => (kind = ContextValueKind.MaxpNumGlyphs) == ContextValueKind.MaxpNumGlyphs,
            "numberOfHMetrics" => (kind = ContextValueKind.HheaNumberOfHMetrics) == ContextValueKind.HheaNumberOfHMetrics,
            "numOfLongVerMetrics" => (kind = ContextValueKind.VheaNumOfLongVerMetrics) == ContextValueKind.VheaNumOfLongVerMetrics,
            _ => false
        };
    }

    private static uint TagToUInt32(string tag)
    {
        unchecked
        {
            return ((uint)tag[0] << 24)
                 | ((uint)tag[1] << 16)
                 | ((uint)tag[2] << 8)
                 | tag[3];
        }
    }

    private enum ContextValueKind
    {
        MaxpNumGlyphs,
        HheaNumberOfHMetrics,
        VheaNumOfLongVerMetrics
    }

    private enum TryFromPlanKind
    {
        Font,
        Table
    }

    private enum TryFromParameterKind
    {
        Table,
        Context
    }

    private sealed record ConstructionPlan(
        string NewExpression,
        ImmutableArray<ContextValue> ContextValues)
    {
        public bool RequiresContext => ContextValues.Length != 0;

        public bool ContainsContextKind(ContextValueKind kind)
        {
            for (int i = 0; i < ContextValues.Length; i++)
            {
                if (ContextValues[i].Kind == kind)
                    return true;
            }

            return false;
        }
    }

    private sealed record ContextValue(
        ContextValueKind Kind,
        string LocalName);

    private sealed record TryFromPlan(
        TryFromPlanKind Kind,
        ImmutableArray<string> TableTypes,
        ImmutableArray<TryFromParameter> Parameters);

    private sealed record TryFromParameter(
        TryFromParameterKind Kind,
        string TypeName,
        string? Tag,
        ContextValueKind ContextKind,
        string Name)
    {
        public static TryFromParameter Table(string typeName, string tag)
            => new(TryFromParameterKind.Table, typeName, tag, default, Name: string.Empty);

        public static TryFromParameter Context(ContextValueKind kind, string name)
            => new(TryFromParameterKind.Context, TypeName: string.Empty, Tag: null, kind, name);
    }

    private sealed record CodecInfo(
        string Tag,
        string BuilderType,
        ConstructionPlan Construction,
        ImmutableArray<TryFromPlan> TryFromPlans);
}
