using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace OTFontFile.Generators;

[Generator]
public class OTTableGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all classes with [OTTable] attribute
        var tableDeclarations = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsCandidateClass(s),
                transform: static (ctx, _) => GetTableInfo(ctx))
            .Where(static m => m is not null);

        // Register source output
        context.RegisterSourceOutput(tableDeclarations,
            static (spc, tableInfo) => Execute(spc, tableInfo!));
    }

    private static bool IsCandidateClass(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax cls &&
               cls.AttributeLists.Count > 0 &&
               cls.Modifiers.Any(SyntaxKind.PartialKeyword);
    }

    private static TableInfo? GetTableInfo(GeneratorSyntaxContext context)
    {
        var classDecl = (ClassDeclarationSyntax)context.Node;
        var symbol = context.SemanticModel.GetDeclaredSymbol(classDecl);
        if (symbol is null) return null;

        // Check for OTTable attribute
        var tableAttr = symbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name == "OTTableAttribute");
        if (tableAttr is null) return null;

        var tag = tableAttr.ConstructorArguments[0].Value?.ToString() ?? "";

        // Check for OTCacheable attribute
        var cacheableAttr = symbol.GetAttributes()
            .FirstOrDefault(a => a.AttributeClass?.Name == "OTCacheableAttribute");
        int fixedSize = 0;
        if (cacheableAttr?.NamedArguments.FirstOrDefault(a => a.Key == "FixedSize").Value.Value is int size)
            fixedSize = size;

        // Get fields with OTField attribute
        var fields = new List<FieldInfo>();
        foreach (var member in symbol.GetMembers())
        {
            if (member is not IFieldSymbol fieldSymbol) continue;
            
            var fieldAttr = fieldSymbol.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.Name == "OTFieldAttribute");
            if (fieldAttr is null) continue;

            var offset = (int)fieldAttr.ConstructorArguments[0].Value!;
            var fieldType = (int)fieldAttr.ConstructorArguments[1].Value!;

            var fieldName = fieldSymbol.Name;
            var propName = StringExtensions.ToPascalCase(fieldName);
            
            fields.Add(new FieldInfo
            {
                FieldName = fieldName,
                PropertyName = propName,
                Offset = offset,
                FieldType = (OTFieldType)fieldType,
                ClrType = fieldSymbol.Type.ToDisplayString()
            });
        }

        if (fields.Count == 0) return null;

        return new TableInfo
        {
            Namespace = symbol.ContainingNamespace.ToDisplayString(),
            ClassName = symbol.Name,
            Tag = tag,
            FixedSize = fixedSize,
            Fields = fields.OrderBy(f => f.Offset).ToList()
        };
    }

    private static void Execute(SourceProductionContext context, TableInfo tableInfo)
    {
        var source = GenerateSource(tableInfo);
        context.AddSource($"{tableInfo.ClassName}.g.cs", SourceText.From(source, Encoding.UTF8));
    }

    private static string GenerateSource(TableInfo info)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine($"namespace {info.Namespace}");
        sb.AppendLine("{");
        sb.AppendLine($"    public partial class {info.ClassName}");
        sb.AppendLine("    {");
        
        // Generate FieldOffsets enum
        sb.AppendLine("        public enum FieldOffsets");
        sb.AppendLine("        {");
        foreach (var field in info.Fields)
        {
            sb.AppendLine($"            {field.PropertyName} = {field.Offset},");
        }
        sb.AppendLine("        }");
        sb.AppendLine();
        
        // Generate property accessors
        foreach (var field in info.Fields)
        {
            var getter = GetBufferGetter(field.FieldType);
            sb.AppendLine($"        public {field.ClrType} {field.PropertyName}");
            sb.AppendLine($"            => m_bufTable.{getter}((uint)FieldOffsets.{field.PropertyName});");
            sb.AppendLine();
        }

        // Generate cache class if FixedSize > 0
        if (info.FixedSize > 0)
        {
            GenerateCacheClass(sb, info);
        }
        
        sb.AppendLine("    }");
        sb.AppendLine("}");
        
        return sb.ToString();
    }

    private static void GenerateCacheClass(StringBuilder sb, TableInfo info)
    {
        var cacheName = $"{info.ClassName.Replace("Table_", "")}_cache";
        
        sb.AppendLine($"        public class {cacheName} : DataCache");
        sb.AppendLine("        {");
        
        // Fields
        foreach (var field in info.Fields)
        {
            sb.AppendLine($"            protected {field.ClrType} m_{field.PropertyName};");
        }
        sb.AppendLine();
        
        // Constructor
        sb.AppendLine($"            public {cacheName}({info.ClassName} owner)");
        sb.AppendLine("            {");
        foreach (var field in info.Fields)
        {
            sb.AppendLine($"                m_{field.PropertyName} = owner.{field.PropertyName};");
        }
        sb.AppendLine("            }");
        sb.AppendLine();
        
        // Properties
        foreach (var field in info.Fields)
        {
            sb.AppendLine($"            public {field.ClrType} {field.PropertyName}");
            sb.AppendLine("            {");
            sb.AppendLine($"                get => m_{field.PropertyName};");
            sb.AppendLine("                set");
            sb.AppendLine("                {");
            sb.AppendLine($"                    m_{field.PropertyName} = value;");
            sb.AppendLine("                    m_bDirty = true;");
            sb.AppendLine("                }");
            sb.AppendLine("            }");
            sb.AppendLine();
        }
        
        // GenerateTable
        sb.AppendLine("            public override OTTable GenerateTable()");
        sb.AppendLine("            {");
        sb.AppendLine($"                var buf = new MBOBuffer({info.FixedSize});");
        foreach (var field in info.Fields)
        {
            var setter = GetBufferSetter(field.FieldType);
            sb.AppendLine($"                buf.{setter}(m_{field.PropertyName}, (uint){info.ClassName}.FieldOffsets.{field.PropertyName});");
        }
        sb.AppendLine($"                return new {info.ClassName}(\"{info.Tag}\", buf);");
        sb.AppendLine("            }");
        
        sb.AppendLine("        }");
    }

    private static string GetBufferGetter(OTFieldType type) => type switch
    {
        OTFieldType.UShort => "GetUshort",
        OTFieldType.Short => "GetShort",
        OTFieldType.UInt => "GetUint",
        OTFieldType.Int => "GetInt",
        OTFieldType.Long => "GetLong",
        OTFieldType.Fixed => "GetFixed",
        OTFieldType.Offset16 => "GetUshort",
        OTFieldType.Offset32 => "GetUint",
        OTFieldType.SByte => "GetSbyte",
        OTFieldType.Byte => "GetByte",
        OTFieldType.Tag => "GetTag",
        _ => "GetUshort"
    };

    private static string GetBufferSetter(OTFieldType type) => type switch
    {
        OTFieldType.UShort => "SetUshort",
        OTFieldType.Short => "SetShort",
        OTFieldType.UInt => "SetUint",
        OTFieldType.Int => "SetInt",
        OTFieldType.Long => "SetLong",
        OTFieldType.Fixed => "SetFixed",
        OTFieldType.Offset16 => "SetUshort",
        OTFieldType.Offset32 => "SetUint",
        OTFieldType.SByte => "SetSbyte",
        OTFieldType.Byte => "SetByte",
        OTFieldType.Tag => "SetTag",
        _ => "SetUshort"
    };
}

internal class TableInfo
{
    public string Namespace { get; set; } = "";
    public string ClassName { get; set; } = "";
    public string Tag { get; set; } = "";
    public int FixedSize { get; set; }
    public List<FieldInfo> Fields { get; set; } = new();
}

internal class FieldInfo
{
    public string FieldName { get; set; } = "";
    public string PropertyName { get; set; } = "";
    public int Offset { get; set; }
    public OTFieldType FieldType { get; set; }
    public string ClrType { get; set; } = "";
}

internal static class StringExtensions
{
    public static string ToPascalCase(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;
        
        // Remove leading underscore and capitalize first letter
        if (name.StartsWith("_"))
            name = name.Substring(1);
        
        if (name.Length == 0) return name;
        return char.ToUpperInvariant(name[0]) + name.Substring(1);
    }
}
